import "tree_base.bs"

namespace Rotor.ViewBuilder

    class TreeRoot

        node as object

        children = {}

        viewModelState = {}

        id = ""
        HID = "0"
        vmHID = "0"
        parentHID = invalid
        isViewModel = true
        childrenHIDhash = {}

        function getFrameworkInstance() as object
            return GetGlobalAA().rotor_framework_helper.frameworkInstance
        end function

        sub render(payloads as dynamic, params = {} as object)
            for each payload in Rotor.Utils.ensureArray(payloads)
                if payload.DoesExist("id") = false and payload.DoesExist("HID") = false
                    payload.id = m.id
                    payload.HID = m.HID
                end if
            end for
            if Rotor.Utils.isValid(params.callback) then params.callbackScope = m
            m.getFrameworkInstance().builder.render(payloads, params)
        end sub

        sub erase(payloads as dynamic, shouldSkipNodePool)
            m.getFrameworkInstance().builder.erase(payloads, m.parentHID, shouldSkipNodePool)
        end sub

        sub destroy()
            m.node = invalid
        end sub

    end class

    class WidgetTree extends Rotor.ViewBuilder.WidgetTreeBase

        ' sub new()
        ' end sub

        sub init()
        end sub

        sub destroy()
            m.tree.destroy()
            m.tree_HIDHash.stack.Clear()
        end sub

        function add(config as object, ViewModelClass = invalid) as object

            if Rotor.Utils.isFunction(ViewModelClass as function) ' Custom View extends Widget
                ' bs:disable-next-line
                widget = new ViewModelClass()
            else
                widget = new Rotor.Widget() ' Standard Widget
            end if

            id = config.id

            ' Parse config properties
            widget.id = id
            widget.childrenHIDhash = {} ' prepare local HID cache
            widget.isRootChild = config.parentHID = "0" ' detect root
            widget.children = {} ' default

            ' Check if has parent widget
            if widget.isRootChild
                parent = m.tree
            else
                parent = m.get(config.parentHID)
            end if
            widget.parentHID = config.parentHID
            HID = m.generateHID(parent)

            ' register as child by readable id
            parent.children[LCase(id)] = widget

            ' register as child by readable HID (Hierarchical Identifier)
            parent.childrenHIDhash[HID] = true ' local cache for HID

            widget.HID = HID
            widget.parent = parent ' link parent widget

            if widget?.isViewModel = true
                widget.vmHID = widget.HID ' start new VM reference in hierarchy
            else
                widget.vmHID = parent.vmHID ' populate down the current VM reference in hierarchy
                VM = m.getByHID(parent.vmHID)
                widget.props = VM.props ' reference to ancestor's viewModel's props (sharing props across descendant widgets)
                widget.viewModelState = VM.viewModelState ' reference to ancestor ViewModel's viewModelState
            end if


            ' Build virtual widget tree
            m.tree_HIDHash.set(HID, widget)

            return widget
        end function

        function getChildrenWidgets(searchPattern as string, HID = "0" as string) as object

            parentWidget = m.get(searchPattern, HID)
            if parentWidget = invalid then return invalid

            childrenWidgets = parentWidget.children.items()

            childrenWidgetsCount = childrenWidgets.Count()
            childrenNodes = parentWidget.node.getChildren(-1, 0)

            orderedWidgets = []
            for each node in childrenNodes
                isFound = false
                itemIndex = 0
                while isFound = false and itemIndex < childrenWidgetsCount
                    widget = childrenWidgets[itemIndex].value
                    if widget.node.isSameNode(node)
                        orderedWidgets.push(widget)
                        isFound = true
                    else
                        itemIndex++
                    end if
                end while
            end for

            return orderedWidgets
        end function

        sub remove (HID as string)
            widget = m.getByHID(HID)
            ' if widget = invalid then return

            ' remove from parent
            parent = widget.parent
            parent.children.Delete(widget.id)

            parent.childrenHIDhash.Delete(widget.HID)

            m.tree_HIDHash.remove(HID)

            ' remove animators
            if widget.animators <> invalid and widget.animators.Count() > 0
                for each animatorId in widget.animators
                    widget.animator(animatorId).destroy()
                end for
            end if

            if widget.isViewModel = true
                widget.props.Clear()
                widget.viewModelState.Clear()
            end if

            widget.Clear()

        end sub

        ' * Helpers

        function isBranchOfRemove(widget as object) as boolean
            if false = widget.DoesExist("markedToRemove") then return false
            if widget.isRootChild = true
                return true
            end if

            return widget.parent.DoesExist("markedToRemove") ? false : true
        end function

        function isBranchOfAppend(widget as object) as boolean
            if false = widget.DoesExist("markedToAppend") then return false
            if widget.isRootChild = true
                return true
            end if
            return widget.parent.DoesExist("markedToAppend") ? false : true
        end function

        function getTreeItem(HID)
            return HID = "" ? m.tree : m.getByHID(HID)
        end function

        ' Deprecated
        ' function checkRegexIncluded(part as string) as object
        '     if Left(part, 6) = "regex:"
        '         return {
        '             isRegex: true,
        '             regex: CreateObject("roRegex", Right(part, Len(part) - 6), "i")
        '         }
        '     else
        '         return {
        '             isRegex: false
        '         }
        '     end if
        ' end function

        sub setRootNode (node as object)
            m.tree.node = node
        end sub

        function getRootNode() as object
            return m.tree.node
        end function
    end class

end namespace
