namespace Rotor.ViewBuilder

    class WidgetTreeBase

        tree = new TreeRoot()
        tree_HIDHash = new Rotor.BaseStack()

        ' sub new()
        '     super()
        ' end sub
        function generateHID(parent) as string
            tryCounter = 32
            newHID = ""
            ' Performance way
            while tryCounter > 0 and newHID = ""
                newHID = parent.HID + Rotor.Utils.getUUIDHex(3)
                if parent.childrenHIDhash.DoesExist(newHID) = true
                    newHID = ""
                end if
                tryCounter--
            end while
            ' Ok, then try another way (very rare scenario)
            if newHID = ""
                for decValue = 0 to 4095
                    hexValue = stri(decValue, 16)
                    newHID = parent.HID + hexValue
                    if parent.childrenHIDhash.DoesExist(newHID) = true
                        newHID = ""
                        exit for
                    end if
                end for
            end if
            return newHID
        end function

        function get(searchPattern as string, HID = "0" as string) as object
            untilFirstItem = true
            results = m.find(searchPattern, HID, untilFirstItem)
            if results = invalid
                return invalid
            else
                return results.shift()
            end if
        end function

        function getByHID(HID as string) as object
            return HID = "0" ? m.tree : m.tree_HIDHash.get(HID)
        end function

        function hasByHID(HID as string) as boolean
            return m.tree_HIDHash.has(HID)
        end function


        ' * Find a widget by unique HID / glob pattern by id / regex

        ''''''''''
        ' find: Searches the widget tree using a path-like glob pattern or direct HID
        '
        ' Supports:
        '   - Direct lookup by HID
        '   - Relative path resolution (./ and .. operators)
        '   - Glob patterns: *, ** and normalization (e.g. multiple slashes, stars)
        '
        ' @param {string} searchPattern - The lookup expression
        ' @param {string} HID - Optional starting node (default: root)
        ' @param {boolean} untilFirstItem - If true, stops after first match
        ' @return {object} - Array of matching widgets, or invalid if none found
        ''''''''''
        function find(searchPattern as string, HID = "0" as string, untilFirstItem = false as boolean) as object
            ' TODO: In the future, this could use a well-designed ID-based cache to improve performance

            ' Direct lookup: if the search pattern is an HID
            if m.hasByHID(searchPattern) = true
                return [m.getByHID(searchPattern)]
            end if

            ' Check if the pattern begins with "./" (relative to root)
            prefix = Left(searchPattern, 2)
            if prefix = "./"
                searchPattern = Right(searchPattern, Len(searchPattern) - 2)
                HID = "0" ' Reset to root if explicitly referencing from top
            end if

            ' Normalize search pattern
            searchPattern = /^\/*/.ReplaceAll(searchPattern, "") ' Remove leading slashes
            searchPattern = /\/{2,}/.ReplaceAll(searchPattern, "/") ' Replace multiple slashes with one
            searchPattern = /\*{3,}/.ReplaceAll(searchPattern, "**") ' Replace 3+ stars with **
            searchPattern = /\*\*$/.ReplaceAll(searchPattern, "*") ' Convert trailing ** to *
            searchPattern = /(\*\*\/){2,}/.ReplaceAll(searchPattern, "**/")' Collapse multiple **/** into one

            searchPattern = LCase(searchPattern)
            parts = /\//.Split(searchPattern)

            startNode = HID = "0" ? m.tree : m.getByHID(HID)

            ' Resolve ".." (parent) operators
            while parts[0] = ".." and startNode.HID <> "0"
                parts.shift()
                startNode = m.getByHID(startNode.parentHID)
            end while

            ' Add leading "**" if not present â€“ this helps recover from human error
            if parts[0] <> "**" then parts.unshift("**")

            results = []

            lastPart = parts[parts.Count() - 1]
            if startNode.HID <> "0" and startNode.id = lastPart
                results.unshift(startNode)
            end if

            ' Begin recursive search
            m.recursionFind(results, parts, untilFirstItem, startNode.children)

            if results.Count() = 0 then return invalid

            return results
        end function


        ''''''''''
        ' recursionFind: Recursively finds widgets in a tree structure based on glob-like patterns
        '
        ' Supports:
        '   - "*" to match any key at one level
        '   - "**" to match any number of nested levels
        '
        ' @param {object} results - Array to collect matching widgets
        ' @param {object} parts - Pattern parts split by "/"
        ' @param {boolean} untilFirstItem - If true, stops after the first match
        ' @param {object} children - The widget tree branch to search (defaults to empty object)
        ' @param {integer} index - Current position in the pattern
        ' @return {object} - Array of matching widgets
        ''''''''''
        function recursionFind(results as object, parts as object, untilFirstItem as boolean, children = {} as object, index = 0 as integer) as object
            currentPart = parts[index]
            partsCount = parts.Count()
            isLastPart = (partsCount - 1 = index)
            nextPart = isLastPart ? "" : parts[index + 1]

            if children.Count() > 0
                for each key in children
                    widget = children[key]

                    if isLastPart = true
                        if currentPart = "*" or currentPart = key
                            results.push(widget)
                            if untilFirstItem = true then return results
                        end if
                    else
                        nextChildren = {}
                        matchedParent = false

                        if currentPart = "**"
                            if nextPart = "*" or nextPart = key
                                matchedParent = true
                                nextChildren = children
                            else
                                nextChildren = widget.children
                            end if
                        else if currentPart = "*" or currentPart = key
                            matchedParent = true
                            nextChildren = widget.children
                        end if

                        newIndex = matchedParent = true ? index + 1 : index

                        if nextChildren.Count() > 0 and newIndex < partsCount
                            m.recursionFind(results, parts, untilFirstItem, nextChildren, newIndex)
                        end if
                    end if
                end for
            end if

            return results
        end function

        function getSubtreeClone(searchPattern as string, keyPathList = [] as object, parentHID = "0" as string) as object
            subTree = m.get(searchPattern, parentHID)
            if subTree = invalid then return invalid

            ' keyPathList.push("id")
            keyPathList.push("HID")
            ' keyPathList.push("parentHID")

            subTreeClone = {}
            m.recursion_getSubtreeClone(subTree, subTreeClone, keyPathList)

            return subTreeClone
        end function

        ' Note that, there will be a type conversion: tree use AA for children but you will need Array for updates.
        sub recursion_getSubtreeClone(subTree as object, subTreeClone as object, keyPathList as object)
            ' Note that
            for each keyPath in keyPathList
                clonedValue = Rotor.Utils.getCloneByKeyPath(subTree, keyPath)
                if clonedValue <> invalid
                    Rotor.Utils.deepExtendAA(subTreeClone, clonedValue)
                end if
            end for
            if subTree.children <> invalid and subTree.children.Count() > 0
                subTreeClone.children = []
                childIndex = 0
                for each id in subTree.children
                    subTreeClone.children.push({ id: id })
                    m.recursion_getSubtreeClone(subTree.children[id], subTreeClone.children[childIndex], keyPathList)
                    childIndex++
                end for
            end if
        end sub

    end class

end namespace
