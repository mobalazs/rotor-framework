' constants
import "engine/Constants.bs"

' engine
import "engine/builder/Builder.bs"
import "engine/services/I18n.bs"
import "engine/providers/DispatcherProvider.bs"
import "engine/providers/Dispatcher.bs"
import "engine/animator/Animator.bs"

' base classes
import "base/BaseWidget.bs"
import "base/DispatcherCreator.bs"
import "base/DispatcherExternal.bs"
import "base/BaseReducer.bs"
import "base/BaseModel.bs"
import "base/BaseStack.bs"
import "base/BaseViewModel.bs"

' utils
import "utils/GeneralUtils.bs"
import "utils/NodeUtils.bs"
import "utils/ArrayUtils.bs"

' plugins
import "plugins/DispatcherProviderPlugin.bs"
import "plugins/FieldsPlugin.bs"
import "plugins/FontStylePlugin.bs"
import "plugins/ObserverPlugin.bs"
import "plugins/FocusPlugin.bs"

namespace Rotor

    '''''''''
    ' ▗▄▄▖  ▗▄▖▗▄▄▄▖▗▄▖ ▗▄▄▖     ▗▄▄▄▖▗▄▄▖  ▗▄▖ ▗▖  ▗▖▗▄▄▄▖▗▖ ▗▖ ▗▄▖ ▗▄▄▖ ▗▖ ▗▖
    ' ▐▌ ▐▌▐▌ ▐▌ █ ▐▌ ▐▌▐▌ ▐▌    ▐▌   ▐▌ ▐▌▐▌ ▐▌▐▛▚▞▜▌▐▌   ▐▌ ▐▌▐▌ ▐▌▐▌ ▐▌▐▌▗▞▘
    ' ▐▛▀▚▖▐▌ ▐▌ █ ▐▌ ▐▌▐▛▀▚▖    ▐▛▀▀▘▐▛▀▚▖▐▛▀▜▌▐▌  ▐▌▐▛▀▀▘▐▌ ▐▌▐▌ ▐▌▐▛▀▚▖▐▛▚▖
    ' ▐▌ ▐▌▝▚▄▞▘ █ ▝▚▄▞▘▐▌ ▐▌    ▐▌   ▐▌ ▐▌▐▌ ▐▌▐▌  ▐▌▐▙▄▄▖▐▙█▟▌▝▚▄▞▘▐▌ ▐▌▐▌ ▐▌
    ' Rotor Framework™               © 2025 Balázs Molnár. All rights reserved.
    '''''''''
    class Framework

        name = "Rotor Framework"
        version = "0.2.3"

        config = {
            tasks: invalid, ' @array    (optional)
            onReady: invalid, ' @function (optional)
            rootNode: invalid, ' @sgNode   (optional)
            readyFieldId: invalid, ' @string   (optional)
            nodePool: invalid, ' @array    (optional)


            debug: {
                autoSetNodeId: false
            },

            plugins: [
                new Rotor.FieldsPlugin("fields"),
                new Rotor.FontStylePlugin("fontStyle"),
                new Rotor.FocusPlugin("focus")
                new Rotor.DispatcherProviderPlugin("dispatcher"),
                new Rotor.ObserverPlugin("observer")
            ]
        }

        threadType = Rotor.Const.ThreadType.RENDER

        ' subsystems
        builder as object
        i18nService as object
        dispatcherProvider as object
        animatorProvider as object
        info = {
            device: {}
        }

        ' plugin adapter workspace
        plugins = {}

        ' sync
        taskOperationalFlag = {}
        taskSyncReadyFlag = {}
        taskNodes = {}

        enableRendering = true

        ' helper vars
        deviceInfo as object

        sub new(config = {})

            Rotor.Utils.deepExtendAA(m.config, config)

            m.builder = new Rotor.ViewBuilder.Builder()
            m.i18nService = new Rotor.ViewBuilder.I18nService()
            m.animatorProvider = new Rotor.Animator()
            m.dispatcherProvider = new Rotor.DispatcherProvider(m.threadType)

            globalScope = GetGlobalAA()
            globalScope.rotor_framework_helper = {
                threadType: m.threadType,
                frameworkInstance: m
            }

            m.initInfo()

            m.builder.init(m)
            m.i18nService.init(m)

            ' set root node
            if m.config.rootNode = invalid
                rootNode = globalScope.top
                m.config.rootNode = rootNode
            else
                rootNode = m.config.rootNode
            end if
            m.builder.widgetTree.setRootNode(rootNode)

            ' Configure Node Pool
            if Rotor.Utils.isArray(m.config.nodePool)
                m.presetNodePool({ nodePool: m.config.nodePool })
            end if

            ' Register plugins
            m.registerPlugins(m.config.plugins)

            ' Prepare render for syncing with tasks
            rootNode.addField("rotorSync", "assocarray", true)
            rootNode.observeFieldScoped("rotorSync", "Rotor_syncCallback")

            ' Add Field to notify when all tasks have been synced.
            if m.config.readyFieldId <> invalid
                rootNode.addField(m.config.readyFieldId, "boolean", false)
                rootNode.setField(m.config.readyFieldId, false)
            end if

            ' prepare tasks for syncing
            if config.tasks <> invalid and Rotor.Utils.isArray(config.tasks) and config.tasks.Count() > 0
                m.enableRendering = false ' disable rendering until task sync ready, then call renderQueueFlush()
                taskNames = Rotor.Utils.ensureArray(config.tasks)
                for each taskName in taskNames
                    m.setupTaskForSyncing(taskName)
                end for
            else
                m.isReady()
            end if


        end sub

        ' * Public View Builder methods

        public sub render(payload as object, params = {} as object)
            if Rotor.Utils.isValid(params.callback) then params.callbackScope = m
            m.builder.render(payload, params)
        end sub

        public sub erase(payload as dynamic, shouldSkipNodePool = false as boolean, HID = "0" as string)
            m.builder.erase(payload, shouldSkipNodePool, HID)
        end sub

        public sub registerPlugins(plugins as object)
            m.builder.pluginAdapter.registerPlugins(plugins)
        end sub

        public function findWidgets(searchPattern as string, HID = "0" as string) as object
            return m.builder.widgetTree.find(searchPattern, HID)
        end function

        public function getWidget(searchPattern as string, HID = "0" as string) as object
            return m.builder.widgetTree.get(searchPattern, HID)
        end function

        public function getChildrenWidgets(searchPattern as string, HID = "0" as string) as object
            return m.builder.widgetTree.getChildrenWidgets(searchPattern, HID)
        end function

        public function getWidgetByHID(HID = "0" as string) as object
            return m.builder.widgetTree.getByHID(HID)
        end function

        public function getRootWidget() as object
            return m.builder.widgetTree.getByHID("0")
        end function

        public function getSubtreeClone(searchPattern as string, keyPathList = [] as object, parentHID = "0" as string) as object
            return m.builder.widgetTree.getSubtreeClone(searchPattern, keyPathList, parentHID)
        end function

        public function getRootNode() as object
            return m.builder.widgetTree.getRootNode()
        end function

        public function getDispatcher(dispatcherId as string) as object
            return m.dispatcherProvider.getFacade(dispatcherId, GetGlobalAA())
        end function

        public function animator(animatorId) as object
            return m.animatorProvider.getFactory(animatorId, m)
        end function

        public function getInfo() as object
            return m.info
        end function

        public function getNodePoolInfo() as object
            return m.builder.nodePool.getNodePoolInfo()
        end function

        public function presetNodePool(config) as object
            return m.builder.nodePool.presetNodePool(config)
        end function

        sub initInfo()
            ' Device info
            di = CreateObject("roDeviceInfo")
            ' Make it available on framework instance
            m.deviceInfo = di
            ' Generate app info
            m.info.device.append({
                graphicsPlatform: di.GetGraphicsPlatform(), ' ["opengl"|"directfb"]
                modelDisplayName: di.GetModelDisplayName(),
                OSVersion: di.GetOSVersion(),
                currentLocale: di.GetCurrentLocale(), ' Example: "en_US"
                countryCode: di.GetCountryCode() ' A value that indicates the Streaming Store associated with a user’s Roku account.
            })
            #if debug
                print `[DEVICEINFO] Graphics Platform: ${m.info.device.graphicsPlatform}`
                print `[DEVICEINFO] modelDisplayName: ${m.info.device.modelDisplayName}`
                print `[DEVICEINFO] OSVersion: ${m.info.device.OSVersion}`
            #end if
        end sub

        sub setupTaskForSyncing(taskName as string)
            rootNode = m.getRootNode()
            taskNode = rootNode.createChild(taskName)
            taskId = Rotor.Utils.getUUIDHex(16)

            m.taskNodes[taskId] = taskNode ' collection for later usage
            m.taskOperationalFlag[taskId] = false ' collection for later usage

            Rotor.Utils.setCustomFields(taskNode, {
                taskId: taskId,
                rootNode: rootNode
            })

            ' taskNode.observeFieldScoped("rotorSync", "Rotor_syncCallback")
            taskNode.control = "RUN"
        end sub

        sub setupAdditionalTasks(taskList as object)
            ' check additional tasks
            if taskList = invalid then return

            taskNames = Rotor.Utils.ensureArray(taskList)
            for each taskName in taskNames
                m.setupTaskForSyncing(taskName)
            end for
        end sub

        function areAllTasksOperational() as boolean
            ' Check if all nodes ready (very basic logic (< future improvement)
            if m.taskOperationalFlag.Count() = 0 then return false

            for each flag in m.taskOperationalFlag.Items()
                if flag.value <> true then return false
            end for

            return true
        end function

        function collectExternalDispatcherRegistrations() as object
            registrations = {}
            dispatcherIds = m.dispatcherProvider.getAll().keys()

            for each taskEntry in m.taskNodes.Items()
                taskNode = taskEntry.value

                for each dispatcherId in dispatcherIds
                    dispatcherInstance = m.dispatcherProvider.get(dispatcherId)
                    externalTaskNode = dispatcherInstance.taskNode

                    if not taskNode.isSameNode(externalTaskNode)
                        m.taskSyncReadyFlag[taskNode.taskId] = false ' collection for later usage
                        if registrations[taskNode.taskId] = invalid then registrations[taskNode.taskId] = []
                        registrations[taskNode.taskId].push({
                            dispatcherId: dispatcherId,
                            externalTaskNode: externalTaskNode
                        })
                    end if
                end for
            end for

            return registrations
        end function

        sub dispatchExternalDispatcherRegistrations(registrations as object)
            for each taskId in registrations
                taskNode = m.taskNodes[taskId]
                taskNode.setField("rotorSync", {
                    type: Rotor.Const.ThreadSyncType.REGISTER_EXTERNAL_DISPATCHER,
                    externalDispatcherList: registrations[taskId]
                })
            end for
        end sub

        function haveAllTasksSynced() as boolean
            ' Check if all nodes ready (very basic logic (< future improvement)
            if m.taskSyncReadyFlag.Count() = 0 then return false

            for each flag in m.taskSyncReadyFlag.Items()
                if flag.value <> true then return false
            end for

            return true
        end function

        sub handleTaskSyncing(sync as object)
            taskNode = sync.taskNode

            m.setupAdditionalTasks(sync.tasks)

            ' register incoming dispatchers
            dispatcherIds = sync.dispatcherIds
            if dispatcherIds <> invalid
                m.dispatcherProvider.registerExternalDispatchers(dispatcherIds, taskNode)
            end if

            ' update task status
            m.taskOperationalFlag[taskNode.taskId] = true

            if not m.areAllTasksOperational() then return

            ' if allTasksRunning then create external dispatchers in all tasks
            registrations = m.collectExternalDispatcherRegistrations()
            if registrations.Count() > 0
                m.dispatchExternalDispatcherRegistrations(registrations)
            else
                m.isReady()
            end if
        end sub

        sub handleTaskSynced(taskId as string)
            m.taskSyncReadyFlag[taskId] = true
            if m.haveAllTasksSynced()
                m.isReady()
            end if
        end sub

        ' Notify ready in 3 ways.
        sub isReady()
            m.builder.renderQueueFlush()

            ' Notify ready state on rotorSync field
            m.getRootNode().setField("rotorSync", {
                type: Rotor.Const.ThreadSyncType.SYNC_COMPLETED
            })

            ' Notify ready state by calling onReady fn if configured
            if Rotor.Utils.isFunction(m.config.onReady)
                Rotor.Utils.callbackScoped(m.config.onReady, GetGlobalAA())
            end if

            ' Notify ready state on rotorSync field
            if m.config.readyFieldId <> invalid
                m.getRootNode().setField(m.config.readyFieldId, true)
            end if
        end sub


        ' DESTROY
        public sub destroy()

            rootNode = m.getRootNode()
            for each taskId in m.taskNodes
                taskNode = m.taskNodes[taskId]
                taskNode.setField("rotorSync", {
                    type: Rotor.Const.ThreadSyncType.DESTROY
                })
                rootNode.removeChild(taskNode)
            end for

            m.taskNodes.Clear()

            rootNode.unobserveFieldScoped("rotorSync")

            ' destroy subsystems
            m.builder.destroy()
            m.dispatcherProvider.destroy()
            m.i18nService.destroy()

            ' remove references
            m.animatorProvider = invalid
            globalScope = GetGlobalAA()
            globalScope.rotor_framework_helper = {
                frameworkInstance: invalid
            }
            m.config.rootNode = invalid

            m.info.Clear()
            m.deviceInfo = invalid

        end sub

    end class

    sub syncCallback(msg)
        ' extraInfo = msg.GetInfo()
        ' fieldId = msg.getField()
        sync = msg.getData() ' @type:AA

        framework = GetGlobalAA().rotor_framework_helper.frameworkInstance
        if framework = invalid then return

        taskNode = sync.taskNode

        if sync.type = Rotor.Const.ThreadSyncType.TASK_SYNCING
            framework.handleTaskSyncing(sync)
        else if sync.type = Rotor.Const.ThreadSyncType.TASK_SYNCED
            framework.handleTaskSynced(taskNode.taskId)
        else if sync.type = Rotor.Const.ThreadSyncType.SYNC_COMPLETED
            ' Do nothing
        end if

    end sub



end namespace
