' =========================================================================
' ▗▄▄▖  ▗▄▖▗▄▄▄▖▗▄▖ ▗▄▄▖     ▗▄▄▄▖▗▄▄▖  ▗▄▖ ▗▖  ▗▖▗▄▄▄▖▗▖ ▗▖ ▗▄▖ ▗▄▄▖ ▗▖ ▗▖
' ▐▌ ▐▌▐▌ ▐▌ █ ▐▌ ▐▌▐▌ ▐▌    ▐▌   ▐▌ ▐▌▐▌ ▐▌▐▛▚▞▜▌▐▌   ▐▌ ▐▌▐▌ ▐▌▐▌ ▐▌▐▌▗▞▘
' ▐▛▀▚▖▐▌ ▐▌ █ ▐▌ ▐▌▐▛▀▚▖    ▐▛▀▀▘▐▛▀▚▖▐▛▀▜▌▐▌  ▐▌▐▛▀▀▘▐▌ ▐▌▐▌ ▐▌▐▛▀▚▖▐▛▚▖
' ▐▌ ▐▌▝▚▄▞▘ █ ▝▚▄▞▘▐▌ ▐▌    ▐▌   ▐▌ ▐▌▐▌ ▐▌▐▌  ▐▌▐▙▄▄▖▐▙█▟▌▝▚▄▞▘▐▌ ▐▌▐▌ ▐▌
' Rotor Framework™
' Version 0.7.3
' © 2025 Balázs Molnár — Apache License 2.0
' =========================================================================

' constants
import "engine/Constants.bs"

' engine
import "engine/builder/Builder.bs"
import "engine/services/I18n.bs"
import "engine/services/Tts.bs"
import "engine/providers/DispatcherProvider.bs"
import "engine/providers/Dispatcher.bs"
import "engine/animator/Animator.bs"

' base classes
import "base/BaseWidget.bs"
import "base/DispatcherOriginal.bs"
import "base/DispatcherCrossThread.bs"
import "base/BaseReducer.bs"
import "base/BaseModel.bs"
import "base/BaseStack.bs"
import "base/BaseViewModel.bs"

' utils
import "utils/GeneralUtils.bs"
import "utils/NodeUtils.bs"
import "utils/ArrayUtils.bs"

' plugins
import "plugins/DispatcherProviderPlugin.bs"
import "plugins/FieldsPlugin.bs"
import "plugins/FontStylePlugin.bs"
import "plugins/ObserverPlugin.bs"
import "plugins/FocusPlugin.bs"
namespace Rotor

    '==========================================================================
    '** Framework
    '**
    '** Main Rotor Framework class that orchestrates the entire framework ecosystem.
    '** Provides a reactive, component-based architecture for building Roku applications
    '** with unidirectional data flow, cross-thread state management, and plugin system.
    '**
    '** @param {object} config - Configuration object with the following properties:
    '**   - tasks (array, optional): List of task node names to synchronize with the render thread.
    '**                              When specified, the framework waits for all tasks to initialize
    '**                              before enabling rendering and calling onReady.
    '**   - onReady (function, optional): Callback function invoked when the framework is fully
    '**                                    initialized and all tasks are synced. Called in global scope.
    '**   - rootNode (roSGNode, optional): The root SceneGraph node for the framework. Defaults to
    '**                                     the global 'top' node if not specified.
    '**   - readyFieldId (string, optional): Field name to add to the root node that will be set to
    '**                                       true when the framework is ready. Useful for triggering
    '**                                       observers when initialization completes.
    '**   - nodePool (array, optional): Array of node pool configurations for pre-instantiating
    '**                                  SceneGraph nodes to improve rendering performance.
    '**                                  Supported types: Group, Rectangle, Poster, Label
    '**                                  Format: [{ nodeType: "Label", count: 10 }, ...]
    '**   - debug (object): Debug configuration options
    '**       - autoSetNodeId (boolean): Automatically set node IDs for debugging (default: false)
    '**   - plugins (array): List of plugin instances to register with the framework.
    '**                       Default plugins include: FieldsPlugin, FontStylePlugin, FocusPlugin,
    '**                       DispatcherProviderPlugin, ObserverPlugin
    '**
    '** @example
    '**   framework = new Rotor.Framework({
    '**       tasks: ["DataTask", "NetworkTask"],
    '**       rootNode: m.top,
    '**       readyFieldId: "appReady",
    '**       onReady: sub()
    '**           print "Framework ready!"
    '**       end sub,
    '**       nodePool: [
    '**           { nodeType: "Label", count: 20 },
    '**           { nodeType: "Rectangle", count: 10 }
    '**       ]
    '**   })
    '==========================================================================
    class Framework

        name = "Rotor Framework"
        version = "0.7.3"

        config = {
            tasks: invalid, ' @array    (optional)
            onReady: invalid, ' @function (optional)
            rootNode: invalid, ' @sgNode   (optional)
            readyFieldId: invalid, ' @string   (optional)
            nodePool: invalid, ' @array    (optional)
            allowNativeAudioGuide: true, ' @boolean    (optional)


            debug: {
                autoSetNodeId: false
            },

            plugins: [
                new Rotor.FieldsPlugin(),
                new Rotor.FontStylePlugin(),
                new Rotor.FocusPlugin()
                new Rotor.DispatcherProviderPlugin(),
                new Rotor.ObserverPlugin()
            ]
        }

        threadType = Rotor.Const.ThreadType.RENDER

        ' subsystems
        builder as object
        i18nService as object
        ttsService as object
        dispatcherProvider as object
        animatorProvider as object
        ' plugin adapter workspace
        plugins = {}

        ' sync - task tracking with phase: pending → operational → synced
        tasks = {}                      ' taskId -> { node, phase, dispatchers[] }

        enableRendering = true

        '----------------------------------------------------------------------
        ' new - Initializes the Rotor Framework instance
        '
        ' Sets up the framework subsystems (Builder, I18n, Animator, DispatcherProvider),
        ' initializes device info, registers plugins, and synchronizes with task threads.
        '
        ' @param {object} config - Configuration object (see class documentation for details)
        '
        sub new(config = {})

            Rotor.Utils.deepExtendAA(m.config, config)

            m.builder = new Rotor.ViewBuilder.Builder()
            m.i18nService = new Rotor.ViewBuilder.I18nService()
            m.ttsService = new Rotor.ViewBuilder.TtsService()
            m.animatorProvider = new Rotor.Animator()
            m.dispatcherProvider = new Rotor.DispatcherProvider(m.threadType)

            globalScope = GetGlobalAA()
            globalScope.rotor_framework_helper = {
                threadType: m.threadType,
                frameworkInstance: m
            }

            m.builder.init(m)

            ' set root node
            if m.config.rootNode = invalid
                rootNode = globalScope.top
                m.config.rootNode = rootNode
            else
                rootNode = m.config.rootNode
            end if
            m.builder.widgetTree.setRootNode(rootNode)

            m.i18nService.init(m)
            m.ttsService.init(m, m.config.allowNativeAudioGuide)

            ' Configure Node Pool
            if Rotor.Utils.isArray(m.config.nodePool)
                m.presetNodePool({ nodePool: m.config.nodePool })
            end if

            ' Register plugins
            m.registerPlugins(m.config.plugins)

            ' Prepare render for syncing with tasks
            rootNode.addField("rotorSync", "assocarray", true)
            rootNode.observeFieldScoped("rotorSync", "Rotor_syncCallback")

            ' Add Field to notify when all tasks have been synced.
            if m.config.readyFieldId <> invalid
                rootNode.addField(m.config.readyFieldId, "boolean", false)
                rootNode.setField(m.config.readyFieldId, false)
            end if

            ' prepare tasks for syncing
            if config.tasks <> invalid and Rotor.Utils.isArray(config.tasks) and config.tasks.Count() > 0
                m.enableRendering = false ' disable rendering until task sync ready, then call renderQueueFlush()
                taskNames = Rotor.Utils.ensureArray(config.tasks)
                for each taskName in taskNames
                    m.setupTaskForSyncing(taskName)
                end for
            else
                m.isReady()
            end if


        end sub

        ' =====================================================================
        ' PUBLIC API - VIEW BUILDER METHODS
        ' =====================================================================

        ' ---------------------------------------------------------------------
        ' render - Renders widget tree from declarative configuration
        '
        ' @param {object} payload - Widget tree configuration object
        ' @param {object} params - Optional render parameters (callback, callbackScope, etc.)
        '
        public sub render(payload as object, params = {} as object)
            if Rotor.Utils.isValid(params.callback) then params.callbackScope = m
            m.builder.render(payload, params)
        end sub

        ' ---------------------------------------------------------------------
        ' erase - Removes widget(s) from the tree
        '
        ' @param {dynamic} payload - Widget ID, HID, or array of IDs to remove
        ' @param {boolean} shouldSkipNodePool - If true, removed nodes won't be returned to pool
        ' @param {string} HID - Parent HID context for widget lookup
        '
        public sub erase(payload as dynamic, shouldSkipNodePool = false as boolean, HID = "0" as string)
            m.builder.erase(payload, shouldSkipNodePool, HID)
        end sub

        ' ---------------------------------------------------------------------
        ' findWidgets - Finds all widgets matching glob pattern
        '
        ' @param {string} searchPattern - Glob pattern (e.g., "header.*", "*.button")
        ' @param {string} HID - Parent HID context for search (default: "0" = root)
        ' @returns {object} Array of matching widget instances
        '
        public function findWidgets(searchPattern as string, HID = "0" as string) as object
            return m.builder.widgetTree.find(searchPattern, HID)
        end function

        ' ---------------------------------------------------------------------
        ' getWidget - Gets first widget matching search pattern
        '
        ' @param {string} searchPattern - Widget ID or path (e.g., "header", "header.logo")
        ' @param {string} HID - Parent HID context for search (default: "0" = root)
        ' @returns {object} Widget instance or invalid if not found
        '
        public function getWidget(searchPattern as string, HID = "0" as string) as object
            return m.builder.widgetTree.get(searchPattern, HID)
        end function

        ' ---------------------------------------------------------------------
        ' getTopWidgets - Gets all direct children of root widget
        '
        ' @param {string} matchingPattern - Optional glob pattern to filter results
        ' @returns {object} Array of top-level widget instances
        '
        public function getTopWidgets(matchingPattern = "" as string) as object
            return m.builder.widgetTree.getChildrenWidgets(m.builder.widgetTree.tree, matchingPattern)
        end function

        ' ---------------------------------------------------------------------
        ' getWidgetByHID - Gets widget by Hierarchical ID
        '
        ' @param {string} HID - Hierarchical ID (e.g., "0.header.logo")
        ' @returns {object} Widget instance or invalid if not found
        '
        public function getWidgetByHID(HID = "0" as string) as object
            return m.builder.widgetTree.getByHID(HID)
        end function

        ' ---------------------------------------------------------------------
        ' getRootWidget - Gets the root widget (HID "0")
        '
        ' @returns {object} Root widget instance
        '
        public function getRootWidget() as object
            return m.builder.widgetTree.getByHID("0")
        end function

        ' ---------------------------------------------------------------------
        ' getSubtreeClone - Creates deep clone of widget subtree
        '
        ' @param {string} searchPattern - Widget ID or path to clone
        ' @param {object} keyPathList - Array of key paths to include in clone
        ' @param {string} parentHID - Parent HID context for search
        ' @returns {object} Cloned widget subtree
        '
        public function getSubtreeClone(searchPattern as string, keyPathList = [] as object, parentHID = "0" as string) as object
            return m.builder.widgetTree.getSubtreeClone(searchPattern, keyPathList, parentHID)
        end function

        ' ---------------------------------------------------------------------
        ' getRootNode - Gets the root SceneGraph node
        '
        ' @returns {object} Root SceneGraph node (roSGNode)
        '
        public function getRootNode() as object
            return m.builder.widgetTree.getRootNode()
        end function

        ' ---------------------------------------------------------------------
        ' getDispatcher - Gets dispatcher facade by ID
        '
        ' @param {string} dispatcherId - Dispatcher identifier
        ' @returns {object} Dispatcher facade instance
        '
        public function getDispatcher(dispatcherId as string) as object
            return m.dispatcherProvider.getFacade(dispatcherId, GetGlobalAA())
        end function

        ' ---------------------------------------------------------------------
        ' animator - Gets animator factory for creating animations
        '
        ' @param {dynamic} animatorId - Animator identifier
        ' @returns {object} Animator factory instance
        '
        public function animator(animatorId) as object
            return m.animatorProvider.getFactory(animatorId, m)
        end function

        ' ---------------------------------------------------------------------
        ' getNodePoolInfo - Gets node pool statistics
        '
        ' @returns {object} Node pool information (available nodes, usage, etc.)
        '
        public function getNodePoolInfo() as object
            return m.builder.nodePool.getNodePoolInfo()
        end function

        ' ---------------------------------------------------------------------
        ' presetNodePool - Pre-instantiates nodes for node pool
        '
        ' @param {object} config - Node pool configuration
        ' @returns {object} Node pool instance
        '
        public function presetNodePool(config) as object
            return m.builder.nodePool.presetNodePool(config)
        end function

        ' =====================================================================
        ' INTERNAL METHODS - INITIALIZATION AND TASK SYNCING
        ' =====================================================================

        ' ---------------------------------------------------------------------
        ' registerPlugins - Registers plugin instances with the framework
        '
        ' @param {object} plugins - Array of plugin instances to register
        '
        sub registerPlugins(plugins as object)
            m.builder.pluginAdapter.registerPlugins(plugins)
        end sub

        ' ---------------------------------------------------------------------
        ' setupTaskForSyncing - Prepares a task node for cross-thread syncing
        '
        ' Creates and configures a task node with unique ID and root node reference.
        '
        ' @param {string} taskName - Name of the task component to create
        '
        sub setupTaskForSyncing(taskName as string)
            rootNode = m.getRootNode()
            taskNode = rootNode.createChild(taskName)
            taskId = Rotor.Utils.getUUIDHex(16)

            m.tasks[taskId] = {
                node: taskNode,
                phase: "pending",
                dispatchers: []
            }

            Rotor.Utils.setCustomFields(taskNode, {
                taskId: taskId,
                rootNode: rootNode
            })

            taskNode.control = "RUN"
        end sub

        ' ---------------------------------------------------------------------
        ' setupAdditionalTasks - Sets up additional task nodes dynamically
        '
        ' @param {object} taskList - Array of task names to set up
        '
        sub setupAdditionalTasks(taskList as object)
            if taskList = invalid then return
            for each taskName in Rotor.Utils.ensureArray(taskList)
                m.setupTaskForSyncing(taskName)
            end for
        end sub

        ' ---------------------------------------------------------------------
        ' allTasksInPhase - Checks if all tasks are in given phase
        '
        ' @param {string} phase - Phase to check ("pending", "operational", "synced")
        ' @returns {boolean} True if all tasks are in the given phase
        '
        function allTasksInPhase(phase as string) as boolean
            if m.tasks.Count() = 0 then return false
            for each taskId in m.tasks
                if m.tasks[taskId].phase <> phase then return false
            end for
            return true
        end function

        ' ---------------------------------------------------------------------
        ' getDispatchersNotOnTask - Gets dispatchers that are NOT on given task
        '
        ' @param {object} taskNode - Task node to exclude
        ' @returns {object} Array of { dispatcherId, stateNode } for foreign dispatchers
        '
        function getDispatchersNotOnTask(taskNode as object) as object
            result = []
            for each dispatcherId in m.dispatcherProvider.getAll().keys()
                stateNode = m.dispatcherProvider.get(dispatcherId).stateNode
                if not taskNode.isSameNode(stateNode)
                    result.push({ dispatcherId: dispatcherId, stateNode: stateNode })
                end if
            end for
            return result
        end function

        ' ---------------------------------------------------------------------
        ' broadcastDispatchersToTasks - Sends foreign dispatchers to each task
        '
        ' For each task, sends list of dispatchers that exist on other threads.
        '
        sub broadcastDispatchersToTasks()
            for each taskId in m.tasks
                task = m.tasks[taskId]
                foreignDispatchers = m.getDispatchersNotOnTask(task.node)

                if foreignDispatchers.Count() > 0
                    task.node.setField("rotorSync", {
                        type: Rotor.Const.ThreadSyncType.REGISTER_CROSS_THREAD_DISPATCHER,
                        crossThreadDispatcherList: foreignDispatchers
                    })
                else
                    task.phase = "synced"
                end if
            end for

            ' If no tasks needed dispatchers, we're done
            if m.allTasksInPhase("synced")
                m.isReady()
            end if
        end sub

        ' ---------------------------------------------------------------------
        ' handleTaskSyncing - Handles task syncing phase
        '
        ' Called when a task reports its dispatchers. Registers cross-thread
        ' dispatchers and broadcasts dispatcher map when all tasks are ready.
        '
        ' @param {object} sync - Sync payload { taskNode, dispatcherIds, tasks }
        '
        sub handleTaskSyncing(sync as object)
            taskNode = sync.taskNode
            taskId = taskNode.taskId

            ' Setup any additional tasks this task declared
            m.setupAdditionalTasks(sync.tasks)

            ' Store dispatcher IDs for this task
            m.tasks[taskId].dispatchers = sync.dispatcherIds ?? []
            m.tasks[taskId].phase = "operational"

            ' Register cross-thread dispatchers on render thread
            if sync.dispatcherIds <> invalid
                m.dispatcherProvider.registerCrossThreadDispatchers(sync.dispatcherIds, taskNode)
            end if

            ' Wait for all tasks to be operational
            if not m.allTasksInPhase("operational") then return

            ' All tasks ready - broadcast dispatcher map
            m.broadcastDispatchersToTasks()
        end sub

        ' ---------------------------------------------------------------------
        ' handleTaskSynced - Handles task synced confirmation
        '
        ' @param {string} taskId - ID of the task that has synced
        '
        sub handleTaskSynced(taskId as string)
            m.tasks[taskId].phase = "synced"
            if m.allTasksInPhase("synced")
                m.isReady()
            end if
        end sub

        ' ---------------------------------------------------------------------
        ' isReady - Notifies framework ready state via multiple channels
        '
        ' Flushes render queue, triggers onReady callback, and sets ready field.
        '
        sub isReady()
            m.enableRendering = true
            m.builder.renderQueueFlush()

            ' Notify ready state on rotorSync field
            m.getRootNode().setField("rotorSync", {
                type: Rotor.Const.ThreadSyncType.SYNC_COMPLETED
            })

            ' Notify ready state by calling onReady fn if configured
            if Rotor.Utils.isFunction(m.config.onReady)
                Rotor.Utils.callbackScoped(m.config.onReady, GetGlobalAA())
            end if

            ' Notify ready state on rotorSync field
            if m.config.readyFieldId <> invalid
                m.getRootNode().setField(m.config.readyFieldId, true)
            end if
        end sub

        ' =====================================================================
        ' CLEANUP
        ' =====================================================================

        ' ---------------------------------------------------------------------
        ' destroy - Cleans up framework resources
        '
        ' Destroys all task nodes, unregisters observers, and cleans up subsystems.
        '
        public sub destroy()

            rootNode = m.getRootNode()
            for each taskId in m.tasks
                task = m.tasks[taskId]
                task.node.setField("rotorSync", {
                    type: Rotor.Const.ThreadSyncType.DESTROY
                })
                rootNode.removeChild(task.node)
            end for

            m.tasks.Clear()

            rootNode.unobserveFieldScoped("rotorSync")

            ' destroy subsystems
            m.builder.destroy()
            m.dispatcherProvider.destroy()
            m.i18nService.destroy()
            m.ttsService.destroy()

            ' remove references
            m.animatorProvider = invalid
            globalScope = GetGlobalAA()
            globalScope.rotor_framework_helper = {
                frameworkInstance: invalid
            }
            m.config.rootNode = invalid

        end sub

    end class

    ' =====================================================================
    ' syncCallback - Global callback for cross-thread synchronization
    '
    ' Global callback function for cross-thread synchronization messages.
    '
    ' This function is called when the rotorSync field changes on the root node.
    ' It routes sync messages to the appropriate framework handler based on type.
    '
    ' @param {roSGNodeEvent} msg - SceneGraph observer message containing sync data
    ' =====================================================================
    sub syncCallback(msg)
        ' extraInfo = msg.GetInfo()
        ' fieldId = msg.getField()
        sync = msg.getData() ' @type:AA

        framework = GetGlobalAA().rotor_framework_helper.frameworkInstance
        if framework = invalid then return

        taskNode = sync.taskNode

        if sync.type = Rotor.Const.ThreadSyncType.DISPATCH
            ' Cross-thread dispatch from task thread to render thread
            dispatcherId = sync.payload.dispatcherId
            intent = sync.payload.intent
            dispatcherInstance = framework.dispatcherProvider.stack.LookupCI(dispatcherId)
            if dispatcherInstance <> invalid
                dispatcherInstance.dispatch(intent)
            end if
        else if sync.type = Rotor.Const.ThreadSyncType.TASK_SYNCING
            framework.handleTaskSyncing(sync)
        else if sync.type = Rotor.Const.ThreadSyncType.TASK_SYNCED
            framework.handleTaskSynced(taskNode.taskId)
        else if sync.type = Rotor.Const.ThreadSyncType.SYNC_COMPLETED
            ' Do nothing
        end if

    end sub



end namespace
