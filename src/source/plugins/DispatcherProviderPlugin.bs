import "../base/BasePlugin.bs"

namespace Rotor

    ' =====================================================================
    ' DispatcherProviderPlugin - Manages MVI dispatcher integration with widgets
    '
    ' Rotor Framework plugin for managing MVI dispatcher integration with widgets.
    '
    ' Key Responsibilities:
    '   - Provides dispatcher facades to widgets for state management
    '   - Manages dispatcher lifecycle (creation, updates, cleanup)
    '   - Integrates cross-thread MVI pattern with widget context
    '   - Stores dispatcher references in viewModelState for easy access
    '
    ' Usage:
    '   Widget config: dispatcher: "dispatcherId" or dispatcher: ["id1", "id2"]
    '   Access: widget.viewModelState.dispatcher[dispatcherId]
    '
    ' =====================================================================
    class DispatcherProviderPlugin extends Rotor.BasePlugin

        pluginKey = "dispatcher"

        ' =============================================================
        ' LIFECYCLE HOOKS
        ' =============================================================

        hooks = {
            ' ---------------------------------------------------------------------
            ' beforeMount - Attaches dispatchers when widget is mounted
            '
            ' Creates dispatcher facades and stores them in viewModelState.
            '
            ' @param {object} scope - Plugin instance (m)
            ' @param {object} widget - Widget being mounted
            '
            beforeMount: sub(scope as object, widget as object)
                scope.setDispatcherOnContext(widget, scope.pluginKey)
            end sub,

            ' ---------------------------------------------------------------------
            ' beforeUpdate - Updates dispatcher configuration
            '
            ' Extends existing dispatcher list with new IDs (prevents duplicates).
            ' Creates facades for any newly added dispatchers.
            '
            ' @param {object} scope - Plugin instance (m)
            ' @param {object} widget - Widget being updated
            ' @param {dynamic} newValue - New dispatcher ID(s)
            ' @param {dynamic} oldValue - Previous dispatcher ID(s)
            '
            beforeUpdate: sub(scope as object, widget as object, newValue, oldValue = [])
                ' Merge old and new dispatcher IDs (no duplicates)
                oldArrayOfDispatcherIds = Rotor.Utils.ensureArray(oldValue ?? [])
                newArrayOfDispatcherIds = Rotor.Utils.ensureArray(newValue)
                widget[scope.pluginKey] = Rotor.Utils.extendArrayOfStrings(oldArrayOfDispatcherIds, newArrayOfDispatcherIds)
                scope.setDispatcherOnContext(widget, scope.pluginKey)
            end sub,

            ' ---------------------------------------------------------------------
            ' beforeDestroy - Cleans up dispatchers before widget destruction
            '
            ' Destroys all dispatcher facades and clears references.
            '
            ' @param {object} scope - Plugin instance (m)
            ' @param {object} widget - Widget being destroyed
            '
            beforeDestroy: sub(scope as object, widget as object)
                dispatcherFacades = widget.viewModelState[scope.pluginKey]
                if dispatcherFacades.Count() > 0
                    for each dispatcherFacadeKey in dispatcherFacades
                        dispatcherFacadeInstance = dispatcherFacades[dispatcherFacadeKey]
                        dispatcherFacadeInstance.destroy()
                        widget.viewModelState[scope.pluginKey][dispatcherFacadeKey] = invalid
                    end for
                end if
            end sub
        }

        ' =============================================================
        ' DISPATCHER MANAGEMENT
        ' =============================================================

        ' ---------------------------------------------------------------------
        ' setDispatcherOnContext - Creates and stores dispatcher facades
        '
        ' For each dispatcher ID in the widget config:
        '   1. Initializes viewModelState.dispatcher object if needed
        '   2. Checks if facade already exists for this ID
        '   3. Creates new facade via DispatcherProvider if not present
        '   4. Stores facade in viewModelState.dispatcher[dispatcherId]
        '
        ' @param {object} widget - Widget instance
        ' @param {string} scopeKey - Plugin key (typically "dispatcher")
        '
        sub setDispatcherOnContext(widget, scopeKey)
            viewModelState = widget.viewModelState
            config = widget[scopeKey]

            for each dispatcherId in Rotor.Utils.ensureArray(config)
                ' Initialize dispatcher storage in viewModelState
                if viewModelState[m.pluginKey] = invalid then viewModelState[m.pluginKey] = {}

                ' Create facade if it doesn't exist
                if not viewModelState[m.pluginKey].DoesExist(dispatcherId)
                    globalScope = GetGlobalAA()
                    frameworkInstance = globalScope.rotor_framework_helper.frameworkInstance
                    viewModelState[m.pluginKey][dispatcherId] = frameworkInstance.dispatcherProvider.getFacade(dispatcherId, widget)
                end if
            end for
        end sub

    end class

end namespace
