import "../base/BasePlugin.bs"

namespace Rotor

    ' =====================================================================
    ' FieldsPlugin - Handles dynamic field expressions and interpolation
    '
    ' Rotor Framework plugin for handling dynamic field expressions and interpolation.
    '
    ' Key Features:
    '   - Evaluates function-based field values
    '   - Interpolates @-prefixed expressions (e.g., @viewModelState.value)
    '   - Supports dynamic field resolution from widget context
    '   - Automatically updates fields on widget lifecycle changes
    '
    ' Expression Syntax:
    '   @key.path - Resolves from widget.viewModelState
    '
    ' =====================================================================
    class FieldsPlugin extends Rotor.BasePlugin

        pluginKey = "fields"

        ' =============================================================
        ' MEMBER VARIABLES
        ' =============================================================

        ' Regex pattern for matching @ and $ prefixed expressions
        ' @ = viewModelState, $ = widget properties
        ' Matches: @ or $ followed by any characters except space, @, $, or comma
        configRegex = /([\@\$])([^\s\@\$\,]*)/i

        ' =============================================================
        ' LIFECYCLE HOOKS
        ' =============================================================

        hooks = {
            ' ---------------------------------------------------------------------
            ' beforeMount - Sets custom fields when widget is mounted
            '
            ' Evaluates and applies all field expressions after widget creation.
            '
            ' @param {object} scope - Plugin instance (m)
            ' @param {object} widget - Widget being mounted
            '
            beforeMount: sub(scope as object, widget as object)
                value = widget[scope.pluginKey]
                scope.setCustomFields(widget, value)
            end sub,

            ' ---------------------------------------------------------------------
            ' beforeUpdate - Updates custom fields when widget config changes
            '
            ' Merges new field config with existing config and re-evaluates all fields.
            '
            ' @param {object} scope - Plugin instance (m)
            ' @param {object} widget - Widget being updated
            ' @param {object} newValue - New field configuration
            ' @param {object} oldValue - Previous field configuration
            '
            beforeUpdate: sub(scope as object, widget as object, newValue = {}, oldValue = {})
                ' Extend old config with new values
                Rotor.Utils.deepExtendAA(widget[scope.pluginKey], newValue)
                scope.setCustomFields(widget, newValue)
            end sub,

            ' ---------------------------------------------------------------------
            ' beforeDestroy - Clears field configuration on destruction
            '
            ' @param {object} scope - Plugin instance (m)
            ' @param {object} widget - Widget being destroyed
            '
            beforeDestroy: sub(scope as object, widget as object)
                widget[scope.pluginKey].Clear()
            end sub
        }

        ' =============================================================
        ' FIELD PROCESSING
        ' =============================================================

        ' ---------------------------------------------------------------------
        ' setCustomFields - Evaluates and applies fields to widget node
        '
        ' Parses field expressions and sets the resolved values on the widget's SceneGraph node.
        '
        ' @param {object} widget - Widget instance
        ' @param {object} fields - Field configuration object
        '
        sub setCustomFields(widget as object, fields)
            parsedFields = m.parseFields(widget, fields)
            node = widget.node
            Rotor.Utils.setCustomFields(node, parsedFields, true)
        end sub

        ' ---------------------------------------------------------------------
        ' parseFields - Parses and resolves field expressions
        '
        ' Processes field values through multiple resolution strategies:
        '   1. Function values - Executes function in widget scope
        '   2. String interpolation - Resolves @-prefixed expressions
        '   3. Direct values - Passes through unchanged
        '
        ' Expression Resolution:
        '   - @key.path resolves from widget.viewModelState
        '   - If result is string, performs string interpolation
        '   - If result is non-string, replaces entire value
        '
        ' @param {object} widget - Widget instance providing context
        ' @param {object} fields - Field configuration to parse
        ' @returns {object} Parsed fields with resolved values
        '
        function parseFields(widget as object, fields as object) as object
            parsedFields = {}

            for each fieldId in fields
                value = fields[fieldId]

                ' Step 1: Resolve function-based values
                if Rotor.Utils.isFunction(value)
                    parsedFields[fieldId] = Rotor.Utils.callbackScoped(value, widget)
                    value = parsedFields[fieldId]
                end if

                ' Step 2: Process string interpolation
                if Rotor.Utils.isString(value)
                    results = m.configRegex.MatchAll(value)

                    if results.Count() > 0
                        for each result in results
                            matchKey = result[2] ' The key path after @
                            sourceTypeOperator = result[1] ' The @ symbol

                            ' Determine source based on operator
                            source = invalid
                            if sourceTypeOperator = "@"
                                source = widget.viewModelState
                            else if sourceTypeOperator = "$"
                                source = widget
                            end if

                            ' Skip if unknown operator
                            if source = invalid then goto nextResult

                            ' Resolve value from key path
                            asset = Rotor.Utils.getValueByKeyPath(source, matchKey)

                            ' Handle string vs non-string results
                            if Rotor.Utils.isString(asset)
                                ' String interpolation - replace in original string
                                replaceRegex = CreateObject("roRegex", sourceTypeOperator + matchKey, "ig")
                                value = replaceRegex.ReplaceAll(value, asset)
                            else
                                ' Non-string value - replace entire field value
                                value = asset
                                exit for
                            end if

                            nextResult:
                        end for
                    end if

                    parsedFields[fieldId] = value
                else
                    ' Step 3: Direct value assignment
                    parsedFields[fieldId] = value
                end if
            end for

            return parsedFields
        end function

    end class

end namespace
