' =========================================================================
' ▗▄▄▖  ▗▄▖▗▄▄▄▖▗▄▖ ▗▄▄▖     ▗▄▄▄▖▗▄▄▖  ▗▄▖ ▗▖  ▗▖▗▄▄▄▖▗▖ ▗▖ ▗▄▖ ▗▄▄▖ ▗▖ ▗▖
' ▐▌ ▐▌▐▌ ▐▌ █ ▐▌ ▐▌▐▌ ▐▌    ▐▌   ▐▌ ▐▌▐▌ ▐▌▐▛▚▞▜▌▐▌   ▐▌ ▐▌▐▌ ▐▌▐▌ ▐▌▐▌▗▞▘
' ▐▛▀▚▖▐▌ ▐▌ █ ▐▌ ▐▌▐▛▀▚▖    ▐▛▀▀▘▐▛▀▚▖▐▛▀▜▌▐▌  ▐▌▐▛▀▀▘▐▌ ▐▌▐▌ ▐▌▐▛▀▚▖▐▛▚▖
' ▐▌ ▐▌▝▚▄▞▘ █ ▝▚▄▞▘▐▌ ▐▌    ▐▌   ▐▌ ▐▌▐▌ ▐▌▐▌  ▐▌▐▙▄▄▖▐▙█▟▌▝▚▄▞▘▐▌ ▐▌▐▌ ▐▌
' Rotor Framework™
' Version 0.7.7
' © 2025-2026 Balázs Molnár — Apache License 2.0
' =========================================================================

' constants
import "engine/Constants.bs"

' engine
import "engine/providers/DispatcherProvider.bs"
import "engine/providers/Dispatcher.bs"

' base classes
import "base/DispatcherOriginal.bs"
import "base/DispatcherCrossThread.bs"
import "base/BaseReducer.bs"
import "base/BaseModel.bs"
import "base/BaseStack.bs"

' utils
import "utils/GeneralUtils.bs"
import "utils/NodeUtils.bs"
import "utils/ArrayUtils.bs"

namespace Rotor
    ' =====================================================================
    ' FrameworkTask - Task thread version of Rotor Framework for MVI
    '
    ' Task thread version of the Rotor Framework that enables cross-thread MVI
    ' (Model-View-Intent) architecture. This class manages state and dispatchers
    ' on a separate task thread, allowing heavy computations and state management
    ' to run off the render thread for better performance.
    '
    ' Configuration:
    '   - tasks (array, optional): List of additional task node names to synchronize with.
    '                             Allows multiple task threads to communicate and share
    '                             dispatchers across different threads.
    '
    ' USAGE NOTES:
    ' The FrameworkTask must be instantiated in the task's init() function and the sync()
    ' method MUST be called at the end of your task function to establish the message loop.
    '
    ' IMPORTANT: The sync() method creates an infinite loop that handles cross-thread
    ' communication and dispatcher synchronization. This call should be the LAST statement
    ' in your task function, after all dispatcher initialization.
    '
    ' Example:
    '   File: MyTask.task.bs
    '   import "pkg:/source/RotorFrameworkTask.bs"
    '   import "pkg:/source/MyDispatcher.bs"
    '
    '   sub init()
    '       m.top.functionName = "task"
    '       m.appFw = new Rotor.FrameworkTask({
    '           tasks: ["AnotherTask"]
    '       })
    '   end sub
    '
    '   sub task()
    '       m.fooDispatcher = createFooDispatcher()
    '       m.barDispatcher = createBarDispatcher()
    '       m.appFw.sync()
    '   end sub
    ' =====================================================================
    class FrameworkTask

        name = "Rotor Framework"
        version = "0.7.7"

        config = {
            tasks: invalid, ' optional
            debug: {
            }
        }

        threadType = Rotor.Const.ThreadType.TASK

        keepAlive = true

        ' helper vars
        taskNode as object
        dispatcherProvider as object
        port as object
        sourceObjectRegistry = {} ' identity -> { dispatcherId, objectId, eventFilter }
        sourceObjectIdIndex = {} ' objectId -> identity (reverse index for unregistration)
        sourceObjectTypeRegistry = [] ' [{ dispatcherId, objectId, eventFilter }] - broadcast routing
        private _eventFilterFn = invalid as dynamic
        onTick as function

        ' ---------------------------------------------------------------------
        ' new - Initializes the FrameworkTask instance
        '
        ' Sets up the task thread dispatcher provider, message port, and
        ' global framework helper for cross-thread communication.
        '
        ' @param {object} config - Configuration object (see class documentation)
        '
        sub new(config = {} as object)

            Rotor.Utils.deepExtendAA(m.config, config)

            globalScope = GetGlobalAA()
            globalScope.rotor_framework_helper = { ' this give to dispatcher instance the possibility to self-register
                threadType: m.threadType,
                frameworkInstance: m
            }
            m.taskNode = globalScope.top

            m.dispatcherProvider = new Rotor.DispatcherProvider(m.threadType)

            m.taskNode.addField("rotorSync", "assocarray", true)
            m.port = CreateObject("roMessagePort")
            m.taskNode.observeFieldScoped("rotorSync", m.port)

        end sub

        ' =====================================================================
        ' PUBLIC API
        ' =====================================================================

        ' ---------------------------------------------------------------------
        ' getDispatcher - Gets dispatcher facade by ID
        '
        ' @param {string} dispatcherId - Dispatcher identifier
        ' @returns {object} Dispatcher facade instance
        '
        public function getDispatcher(dispatcherId as string) as object
            return m.dispatcherProvider.getFacade(dispatcherId, GetGlobalAA())
        end function

        ' ---------------------------------------------------------------------
        ' registerSourceObject - Registers a port-based object for event routing
        '
        ' Generic registry for any Roku port object. Auto-detects routing mode:
        '   - Identity-based: If sourceObject implements ifSourceIdentity, routes via
        '     GetSourceIdentity() on the event (roUrlTransfer, roChannelStore).
        '   - Broadcast: If sourceObject does NOT implement ifSourceIdentity, broadcasts
        '     to all registered dispatchers (roDeviceInfo, roInput, roAppManager).
        '
        ' @param {string} objectId - Unique identifier for this registration
        ' @param {string} dispatcherId - Dispatcher ID that will handle events
        ' @param {object} sourceObject - The port-based object (SetMessagePort will be called)
        ' @param {function} eventFilter - Optional filter function. Receives msg, returns boolean.
        '
        public sub registerSourceObject(objectId as string, dispatcherId as string, sourceObject as object, eventFilter = invalid as dynamic)
            sourceObject.SetMessagePort(m.port)
            if FindMemberFunction(sourceObject, "GetIdentity") <> invalid
                ' Identity-based routing
                identity = sourceObject.GetIdentity().ToStr()
                m.sourceObjectRegistry[identity] = {
                    dispatcherId: dispatcherId,
                    objectId: objectId,
                    eventFilter: eventFilter
                }
                m.sourceObjectIdIndex[objectId] = identity
            else
                ' Broadcast routing
                m.sourceObjectTypeRegistry.push({
                    dispatcherId: dispatcherId,
                    objectId: objectId,
                    eventFilter: eventFilter
                })
            end if
        end sub

        ' ---------------------------------------------------------------------
        ' unregisterSourceObject - Unregisters a port-based object by its objectId
        '
        ' @param {string} objectId - The unique identifier used during registration
        '
        public sub unregisterSourceObject(objectId as string)
            ' Try identity-based registry
            if m.sourceObjectIdIndex.DoesExist(objectId)
                identity = m.sourceObjectIdIndex[objectId]
                m.sourceObjectRegistry.Delete(identity)
                m.sourceObjectIdIndex.Delete(objectId)
                return
            end if
            ' Try broadcast registry
            for i = m.sourceObjectTypeRegistry.count() - 1 to 0 step -1
                if m.sourceObjectTypeRegistry[i].objectId = objectId
                    m.sourceObjectTypeRegistry.Delete(i)
                end if
            end for
        end sub

        ' ---------------------------------------------------------------------
        ' sync - Starts the message loop for cross-thread communication
        '
        ' IMPORTANT: This method creates an infinite loop that handles:
        '   - Intent dispatching from render thread
        '   - External dispatcher registration
        '   - State change notifications
        '   - Async reducer callbacks
        '
        ' This method MUST be the last call in your task function, as it
        ' blocks execution until the framework is destroyed.
        '
        sub sync(waitMs = 0 as integer, onTick = invalid as dynamic)
            m.notifySyncStatus(Rotor.Const.ThreadSyncType.TASK_SYNCING)

            keepAlive = true

            ' Initialize tick timer if waitMs > 0
            lastTickTime = invalid
            if waitMs > 0
                lastTickTime = CreateObject("roTimespan")
                lastTickTime.Mark()
            end if

            while true and keepAlive = true
                msg = wait(waitMs, m.port)

                if msg = invalid
                    ' Timeout - check if tick interval elapsed
                    if waitMs > 0 and onTick <> invalid and lastTickTime <> invalid
                        elapsedMs = lastTickTime.TotalMilliseconds()
                        if elapsedMs >= waitMs
                            ' Tick interval elapsed - call callback
                            Rotor.Utils.callbackScoped(onTick, GetGlobalAA())
                            ' Reset tick timer
                            lastTickTime.Mark()
                        end if
                    end if
                else if msg <> invalid
                    msgType = type(msg)
                    if msgType = "roSGNodeEvent"
                        fieldId = msg.getField()

                        if fieldId = "rotorSync"

                            sync = msg.getData() ' @type:AA

                            if sync.type = Rotor.Const.ThreadSyncType.DISPATCH


                                dispatcherId = sync.payload.dispatcherId
                                intent = sync.payload.intent
                                dispatcherInstance = m.dispatcherProvider.stack.LookupCI(dispatcherId)

                                ' taskIntent = Rotor.Utils.deepCopy(intent)
                                dispatcherInstance.dispatch(intent)

                            else if sync.type = Rotor.Const.ThreadSyncType.REGISTER_CROSS_THREAD_DISPATCHER

                                for each item in sync.crossThreadDispatcherList
                                    m.dispatcherProvider.registerCrossThreadDispatchers(item.dispatcherId, item.stateNode)
                                end for

                                m.notifySyncStatus(Rotor.Const.ThreadSyncType.TASK_SYNCED)

                            else if sync.type = Rotor.Const.ThreadSyncType.DESTROY

                                keepAlive = false

                            end if
                        else

                            data = msg.getData()
                            extraInfo = msg.GetInfo() ' Info AA passed during observeFieldScoped

                            if extraInfo?.dispatcherId <> invalid and m.dispatcherProvider.get(extraInfo?.dispatcherId) <> invalid
                                ' Catch by dispatcherId
                                m.dispatcherProvider.get(extraInfo?.dispatcherId).onSourceEvent(msg, extraInfo?.context as dynamic)
                            else
                                dispatcherId = fieldId
                                dispatcherInstance = m.dispatcherProvider.get(dispatcherId)
                                dispatcherInstance.notifyListeners(data)
                            end if

                        end if
                    else
                        ' Generic port object routing
                        routed = false

                        ' Try identity-based routing
                        if m.sourceObjectRegistry.count() > 0
                            try
                                sourceIdentity = msg.GetSourceIdentity().ToStr()
                                if m.sourceObjectRegistry.DoesExist(sourceIdentity)
                                    entry = m.sourceObjectRegistry[sourceIdentity]

                                    ' Apply event filter if provided
                                    allowed = true
                                    if entry.eventFilter <> invalid
                                        m._eventFilterFn = entry.eventFilter
                                        allowed = m._eventFilterFn(msg)
                                    end if

                                    if allowed
                                        dispatcherInstance = m.dispatcherProvider.get(entry.dispatcherId)
                                        if dispatcherInstance <> invalid
                                            dispatcherInstance.onSourceEvent(msg, invalid)
                                        end if
                                    end if
                                    routed = true
                                end if
                            catch e
                                ' Event doesn't support GetSourceIdentity - fall through to broadcast
                            end try
                        end if

                        ' Broadcast to all non-identity registered dispatchers
                        if not routed
                            for each entry in m.sourceObjectTypeRegistry
                                ' Apply event filter if provided
                                allowed = true
                                if entry.eventFilter <> invalid
                                    m._eventFilterFn = entry.eventFilter
                                    allowed = m._eventFilterFn(msg)
                                end if

                                if allowed
                                    dispatcherInstance = m.dispatcherProvider.get(entry.dispatcherId)
                                    if dispatcherInstance <> invalid
                                        dispatcherInstance.onSourceEvent(msg, invalid)
                                    end if
                                end if
                            end for
                        end if
                    end if
                end if
            end while
            m.destroy()
        end sub

        ' =====================================================================
        ' INTERNAL METHODS
        ' =====================================================================

        ' ---------------------------------------------------------------------
        ' notifySyncStatus - Notifies render thread of sync status
        '
        ' Sends sync status message to render thread via rotorSync field.
        '
        ' @param {string} status - Sync status type (TASK_SYNCING or TASK_SYNCED)
        '
        sub notifySyncStatus(status as string)

            payload = {
                type: status,
                taskNode: m.taskNode
            }

            if status = Rotor.Const.ThreadSyncType.TASK_SYNCING
                payload.append({
                    dispatcherIds: m.dispatcherProvider.stack.Keys(),
                    tasks: m.config.tasks
                })
            end if

            m.taskNode.rootNode.setField("rotorSync", payload)

        end sub

        ' ---------------------------------------------------------------------
        ' addObserver - Adds field observer to task thread message port
        '
        ' @param {string} fieldId - Field name to observe
        ' @param {object} node - SceneGraph node to observe
        '
        sub addObserver(fieldId as string, node)
            node.observeFieldScoped(fieldId, m.port)
        end sub

        ' ---------------------------------------------------------------------
        ' removeObserver - Removes field observer from node
        '
        ' @param {string} fieldId - Field name to stop observing
        ' @param {object} node - SceneGraph node to unobserve
        '
        sub removeObserver(fieldId as string, node)
            node.unobserveFieldScoped(fieldId)
        end sub

        ' =====================================================================
        ' CLEANUP
        ' =====================================================================

        ' ---------------------------------------------------------------------
        ' destroy - Cleans up task thread resources
        '
        ' Destroys dispatcher provider and clears global framework helper.
        '
        public sub destroy()
            m.sourceObjectRegistry.clear()
            m.sourceObjectIdIndex.clear()
            m.sourceObjectTypeRegistry.clear()
            m.dispatcherProvider.destroy()

            globalScope = GetGlobalAA()
            globalScope.rotor_framework_helper = {
                frameworkInstance: invalid
            }

            m.taskNode.rootNode = invalid
            m.taskNode = invalid
        end sub

    end class

end namespace
