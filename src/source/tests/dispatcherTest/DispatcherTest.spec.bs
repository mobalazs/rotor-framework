import "pkg:/source/RotorFramework.bs"
import "pkg:/components/tests/dispatcherTest/DispatcherTest.const.bs"
import "pkg:/components/tests/dispatcherTest/DispatcherTest.template.bs"
import "pkg:/components/tests/dispatcherTest/DispatcherTest.dispatcher.bs"

namespace tests

    @SGNode("dispatcherTest")
    @suite("DispatcherRenderThreadTestSuite integration")
    class DispatcherRenderThreadTestSuite extends rooibos.BaseTestSuite

        fwInstance as Rotor.Framework
        fooDispatcher as Rotor.Dispatcher

        protected override function beforeEach()
            ' Initialize framework
            m.fwInstance = new Rotor.Framework()
            ' Create fooDispatcher instance (owned by the render thread)
            test.createFooDispatcher()
            ' Render
            template = getDispatcherTestTemplate()
            m.fwInstance.render(template)
        end function

        protected override function afterEach()
            m.fwInstance.destroy()
            m.fwInstance = invalid
            m.fooDispatcher = invalid
        end function

        @describe("render-thread dispatcher propagates state to ancestor view")

        @it("propagates render-thread dispatch to ancestor view")
        function _()
            m.fooDispatcher = m.fwInstance.connectDispatcher("fooDispatcher")
            rootWidget = m.fwInstance.getRootWidget()
            ancestorWidget = m.fwInstance.getWidget("ancestorViewModel")
            descendantWidget = m.fwInstance.getWidget("descendantViewModel")

            hitCounter = m.fooDispatcher.getState().hitCounter
            m.assertEqual(hitCounter, 0)

            m.assertEqual(ancestorWidget.props.foo, "bar")

            descendantWidget.dispatchUpdateFoo("baz") ' Runs synchronously since this is not a cross-thread dispatch
            m.assertEqual(ancestorWidget.props.foo, "baz")

            hitCounter = m.fooDispatcher.getState().hitCounter
            m.assertEqual(hitCounter, 1)

            ' Validate dispatch directly + validate middleware
            m.fooDispatcher.dispatch({
                type: IntentTypes.BLOCK_BY_MIDDLEWARE,
                payload: {
                    foo: invalid
                }
            })

            ' state.hitCounter should not change
            hitCounter = m.fooDispatcher.getState().hitCounter
            m.assertEqual(hitCounter, 1, "state.hitCounter should not change when IntentTypes.BLOCK_BY_MIDDLEWARE")

        end function

        @describe("widget dispatcher shortcuts")

        @it("dispatchTo dispatches intent to dispatcher by ID")
        function _()
            ' Create a widget
            ancestorWidget = m.fwInstance.getWidget("ancestorViewModel")

            ' Get initial state
            initialState = ancestorWidget.getStateFrom("fooDispatcher")
            m.assertEqual(initialState.foo, "bar")

            ' Shortcut dispatch using widget
            ancestorWidget.dispatchTo("fooDispatcher", {
                type: IntentTypes.UPDATE_FOO,
                payload: {
                    foo: "baz2"
                }
            })

            ' Verify state changed
            newState = ancestorWidget.getStateFrom("fooDispatcher")
            m.assertEqual(newState.foo, "baz2")
        end function

        @it("getStateFrom returns current state from dispatcher by ID")
        function _()
            ancestorWidget = m.fwInstance.getWidget("ancestorViewModel")

            ' Get state using convenience method
            fooState = ancestorWidget.getStateFrom("fooDispatcher")

            m.assertNotEqual(fooState, invalid)
            m.assertEqual(fooState.foo, "bar")
            m.assertEqual(fooState.hitCounter, 0)
        end function

        @it("getStateFrom returns state without callback parameter")
        function _()
            ancestorWidget = m.fwInstance.getWidget("ancestorViewModel")

            ' Get state without callback (using invalid as second param)
            fooState = ancestorWidget.getStateFrom("fooDispatcher", invalid)

            m.assertNotEqual(fooState, invalid)
            m.assertEqual(fooState.foo, "bar")
            m.assertEqual(fooState.hitCounter, 0)
        end function

        @it("dispatchTo and getStateFrom work together for state updates")
        function _()
            ancestorWidget = m.fwInstance.getWidget("ancestorViewModel")

            ' Multiple dispatches
            ancestorWidget.dispatchTo("fooDispatcher", {
                type: IntentTypes.UPDATE_FOO,
                payload: { foo: "value1" }
            })

            state1 = ancestorWidget.getStateFrom("fooDispatcher")
            m.assertEqual(state1.foo, "value1")
            m.assertEqual(state1.hitCounter, 1)

            ancestorWidget.dispatchTo("fooDispatcher", {
                type: IntentTypes.UPDATE_FOO,
                payload: { foo: "value2" }
            })

            state2 = ancestorWidget.getStateFrom("fooDispatcher")
            m.assertEqual(state2.foo, "value2")
            m.assertEqual(state2.hitCounter, 2)
        end function

    end class
end namespace
