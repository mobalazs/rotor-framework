import "pkg:/source/RotorFramework.bs"
import "pkg:/components/tests/dispatcherTest/DispatcherTest.const.bs"
import "pkg:/components/tests/dispatcherTest/DispatcherTest.template.bs"
import "pkg:/components/tests/dispatcherTest/DispatcherTest.dispatcher.bs"

namespace tests

    ' ******************************************************************
    ' ** Note:
    ' **
    ' ** The main difference between the "DispatcherTest" and the "DispatcherCrossThreadTest"
    ' ** is that the cross-thread Dispatcher runs inside a task thread, demonstrating that
    ' ** the same dispatcher pattern can be used there and available in render thread as well.
    ' ** With this approach, the entire application state management can be implemented -
    ' ** using MVI design patter. It allows building a fetch pool, maintaining a single source of truth, etc.
    ' **
    ' ** It’s important to note that when a Dispatcher is created in the render thread,
    ' ** it can only be used for purposes that exist within that render context —
    ' ** for example, as a controller or logic layer for a specific UI component.
    ' ******************************************************************

    @SGNode("dispatcherTest")
    @suite("dispatcherCrossThreadTest integration")
    class dispatcherCrossThreadTest extends rooibos.BaseTestSuite

        fwInstance = invalid
        isFWReady = false
        expectedCCMode = ""
        originalCCMode = ""
        baselineEventCount = 0
        eventCountAfterUnregister = 0
        baselineTickCount = 0
        countAfterUnregister = 0

        protected override function setup()
            if m.fwInstance = invalid
                m.fwInstance = new Rotor.Framework({
                    tasks: ["DispatcherCrossThreadTest"],
                    onReady: sub() m.testsuite.isFWReady = true : end sub
                })
                ' Template will be queued because framework prepared for deferred rendering until Task Ready state.
                template = getDispatcherTestTemplate()
                m.fwInstance.render(template)
                ' Create a simple dispatcher that runs in the render thread
                Rotor.createDispatcher("renderThreadDispatcher", new TestRenderThreadModel(), new TestRenderThreadReducer())
            end if
        end function

        protected override function beforeEach()
        end function

        protected override function afterEach()
        end function

        @describe("task-thread dispatcher delivers state to render thread")

        @async(8000)
        @it("awaits task-ready signal before assertions")
        function _()
            m.waitForReady()
        end function

        private sub waitForReady()
            if m.isFWReady = true
                m.done()
            else
                rooibos_promises_internal_delay(function(ctx as dynamic)
                    ctx.waitForReady()
                end function, m, 0.1)
            end if
        end sub

        @async()
        @it("reports initial cross-thread dispatcher state")
        function _()
            rootNode = m.fwInstance.getRootNode()
            rootWidget = m.fwInstance.getRootWidget()
            ancestorWidget = m.fwInstance.getWidget("ancestorViewModel")
            descendantWidget = m.fwInstance.getWidget("descendantViewModel")
            m.assertNotEqual(rootWidget, invalid)
            m.assertNotEqual(ancestorWidget, invalid)
            m.assertNotEqual(descendantWidget, invalid)

            fooDispatcher = m.fwInstance.connectDispatcher("fooDispatcher")
            fooDispatcherState = fooDispatcher.getState()
            m.assertEqual(fooDispatcherState.hitCounter, 0)
            m.assertEqual(fooDispatcherState.foo, "bar")

            m.done()
        end function

        @async()
        @it("propagates child dispatch to ancestor view")
        function _()
            fooDispatcher = m.fwInstance.connectDispatcher("fooDispatcher")
            ancestorWidget = m.fwInstance.getWidget("ancestorViewModel")
            descendantWidget = m.fwInstance.getWidget("descendantViewModel")

            m.assertEqual(ancestorWidget.props.foo, "bar")

            ' Start async test: validate dispatchUpdateFoo
            descendantWidget.dispatchUpdateFoo("baz") ' Runs async since this is a cross-thread dispatch
            rooibos_promises_internal_delay(function(ctx as dynamic)
                ancestorWidget = ctx.fwInstance.getWidget("ancestorViewModel")
                ctx.assertEqual(ancestorWidget.props.foo, "baz")

                fooDispatcher = ctx.fwInstance.connectDispatcher("fooDispatcher")
                hitCounter = fooDispatcher.getState().hitCounter
                ctx.assertEqual(hitCounter, 1)

                ctx.done()
            end function, m, 0.09)

        end function

        @describe("source object event routing via registerSourceObject")

        @async()
        @it("routes roDeviceInfo caption mode events to reducer via onSourceEvent")
        function _()
            sourceDispatcher = m.fwInstance.connectDispatcher("sourceObjectDispatcher")
            m.assertNotInvalid(sourceDispatcher)

            ' Capture baseline — roDeviceInfo may fire an initial event when bound to port
            baselineState = sourceDispatcher.getState()
            baselineEventCount = baselineState.eventCount

            ' Toggle CC mode to ensure an event fires
            deviceInfo = CreateObject("roDeviceInfo")
            currentMode = deviceInfo.GetCaptionsMode()
            newMode = "On"
            if currentMode = "On" then newMode = "Off"
            deviceInfo.SetCaptionsMode(newMode)

            ' Store for assertion in async callback
            m.expectedCCMode = newMode
            m.originalCCMode = currentMode
            m.baselineEventCount = baselineEventCount

            ' Wait for event to propagate through task thread
            rooibos_promises_internal_delay(function(ctx as dynamic)
                sourceDispatcher = ctx.fwInstance.connectDispatcher("sourceObjectDispatcher")
                state = sourceDispatcher.getState()
                ctx.assertTrue(state.eventCount > ctx.baselineEventCount, "onSourceEvent should have been called after CC toggle")
                ctx.assertEqual(state.ccMode, ctx.expectedCCMode)

                ' Restore original CC mode
                restoreInfo = CreateObject("roDeviceInfo")
                restoreInfo.SetCaptionsMode(ctx.originalCCMode)

                ctx.done()
            end function, m, 0.5)
        end function

        @async()
        @it("unregisters source object and stops receiving events")
        function _()
            sourceDispatcher = m.fwInstance.connectDispatcher("sourceObjectDispatcher")

            ' Dispatch unregister intent to task thread
            sourceDispatcher.dispatch({ type: IntentTypes.UNREGISTER_SOURCE_OBJECT })

            ' Wait for unregister to propagate, then toggle CC and verify no new events
            rooibos_promises_internal_delay(function(ctx as dynamic)
                sourceDispatcher = ctx.fwInstance.connectDispatcher("sourceObjectDispatcher")
                state = sourceDispatcher.getState()
                ctx.assertTrue(state.unregistered = true, "source object should be unregistered")
                eventCountAfterUnregister = state.eventCount

                ' Toggle CC mode — should NOT trigger onSourceEvent anymore
                deviceInfo = CreateObject("roDeviceInfo")
                currentMode = deviceInfo.GetCaptionsMode()
                newMode = "On"
                if currentMode = "On" then newMode = "Off"
                deviceInfo.SetCaptionsMode(newMode)

                ' Store for second delay check
                ctx.eventCountAfterUnregister = eventCountAfterUnregister
                ctx.originalCCMode = currentMode

                rooibos_promises_internal_delay(function(ctx2 as dynamic)
                    sourceDispatcher = ctx2.fwInstance.connectDispatcher("sourceObjectDispatcher")
                    state = sourceDispatcher.getState()
                    ctx2.assertEqual(state.eventCount, ctx2.eventCountAfterUnregister, "eventCount should not increase after unregister")

                    ' Restore original CC mode
                    restoreInfo = CreateObject("roDeviceInfo")
                    restoreInfo.SetCaptionsMode(ctx2.originalCCMode)

                    ctx2.done()
                end function, ctx, 0.5)
            end function, m, 0.3)
        end function

        @describe("identity-based source object routing via roUrlTransfer")

        @async(5000)
        @it("routes roUrlEvent to reducer via GetSourceIdentity")
        function _()
            transferDispatcher = m.fwInstance.connectDispatcher("transferDispatcher")
            m.assertNotInvalid(transferDispatcher)

            ' POST was fired in onCreateDispatcher — wait for roUrlEvent response
            rooibos_promises_internal_delay(function(ctx as dynamic)
                transferDispatcher = ctx.fwInstance.connectDispatcher("transferDispatcher")
                state = transferDispatcher.getState()
                ctx.assertTrue(state.responseCount > 0, "onSourceEvent should have received roUrlEvent")
                ctx.assertTrue(state.responseCode <> 0, "responseCode should be non-zero (negative = connection error)")

                ctx.done()
            end function, m, 2.0)
        end function

        @async(5000)
        @it("unregisters roUrlTransfer and stops routing events")
        function _()
            transferDispatcher = m.fwInstance.connectDispatcher("transferDispatcher")

            ' Unregister the transfer source object
            transferDispatcher.dispatch({ type: IntentTypes.UNREGISTER_TRANSFER })

            ' Wait for unregister to propagate
            rooibos_promises_internal_delay(function(ctx as dynamic)
                transferDispatcher = ctx.fwInstance.connectDispatcher("transferDispatcher")
                state = transferDispatcher.getState()
                ctx.assertTrue(state.unregistered = true, "transfer should be unregistered")
                countAfterUnregister = state.responseCount

                ' Fire another POST — should NOT be routed anymore
                transferDispatcher.dispatch({ type: IntentTypes.START_TRANSFER })

                ctx.countAfterUnregister = countAfterUnregister

                rooibos_promises_internal_delay(function(ctx2 as dynamic)
                    transferDispatcher = ctx2.fwInstance.connectDispatcher("transferDispatcher")
                    state = transferDispatcher.getState()
                    ctx2.assertEqual(state.responseCount, ctx2.countAfterUnregister, "responseCount should not increase after unregister")

                    ctx2.done()
                end function, ctx, 2.0)
            end function, m, 0.3)
        end function

        @describe("sync tick timer")

        @async()
        @it("invokes onTick callback at specified interval")
        function _()
            sourceDispatcher = m.fwInstance.connectDispatcher("sourceObjectDispatcher")
            baselineTickCount = sourceDispatcher.getState().tickCount

            ' Wait 350ms — with waitMs=100, onTick should fire at least twice
            rooibos_promises_internal_delay(function(ctx as dynamic)
                sourceDispatcher = ctx.fwInstance.connectDispatcher("sourceObjectDispatcher")
                tickCount = sourceDispatcher.getState().tickCount
                ctx.assertTrue(tickCount > ctx.baselineTickCount, "onTick should have incremented tickCount")

                ctx.done()
            end function, m, 0.35)
        end function

        @describe("render thread dispatcher integration")

        @it("render thread dispatcher synchronizes automatically to framework")
        function _()
            ' Dispatcher was created in setup()
            ' Get dispatcher facade - should synchronize automatically
            renderDispatcher = m.fwInstance.connectDispatcher("renderThreadDispatcher")

            ' Should be valid (synchronized)
            m.assertNotInvalid(renderDispatcher)

            ' Should have initial state
            state = renderDispatcher.getState()
            m.assertNotInvalid(state)
            m.assertEqual(state.counter, 0)

            ' Dispatch increment - should work synchronously
            renderDispatcher.dispatch({ type: "INCREMENT" })
            state = renderDispatcher.getState()
            m.assertEqual(state.counter, 1)
        end function

        @describe("task-thread dispatcher middleware and destroy")

        @async()
        @it("ignores BLOCK_BY_MIDDLEWARE intents")
        function _()
            fooDispatcher = m.fwInstance.connectDispatcher("fooDispatcher")
            fooDispatcher.dispatch({
                type: IntentTypes.BLOCK_BY_MIDDLEWARE,
                payload: {
                    foo: invalid
                }
            })
            ' Start async test: validate BLOCK_BY_MIDDLEWARE
            rooibos_promises_internal_delay(function(ctx as dynamic)
                fooDispatcher = ctx.fwInstance.connectDispatcher("fooDispatcher")
                hitCounter = fooDispatcher.getState().hitCounter
                ctx.assertEqual(hitCounter, 1, "state.hitCounter should not change when IntentTypes.BLOCK_BY_MIDDLEWARE")

                ctx.fwInstance.destroy()

                ' Validate proper destroy
                ctx.assertEqual(ctx.fwInstance.tasks.Count(), 0)
                ctx.assertEqual(ctx.fwInstance.getRootWidget().children.Count(), 0)

                ctx.done()
            end function, m, 0.09)
        end function

    end class
end namespace
