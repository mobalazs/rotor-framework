import "pkg:/source/RotorFramework.bs"
import "pkg:/source/engine/Constants.bs"
import "pkg:/components/tests/focusPluginTest/FocusPluginTest.template.bs"

namespace tests

    @SGNode("focusPluginTest")
    @suite("FocusPluginTestSuite integration")
    class FocusPluginTestSuite extends rooibos.BaseTestSuite

        fwInstance as Rotor.Framework

        protected override function beforeEach()
            ' Initialize framework
            m.fwInstance = new Rotor.Framework()
            ' Render
            template = getFocusTestTemplate()
            m.fwInstance.render(template)
            ' Disable longPress feature
            m.fwInstance.plugins.focusenableLongPressFeature = false
            ' Set initial focus to L1 (by using the topWidget group and its capturing feature)
            topWidget = m.fwInstance.getWidget("topWidget")
            topWidget.setFocus()
        end function

        protected override function afterEach()
            m.fwInstance.destroy()
            m.fwInstance = invalid
        end function

        ' ======================================================================
        ' TEST SUITE 1: Initialization and Toggles
        ' ======================================================================

        @describe("initialization and toggles")

        @it("enables focus navigation and validates state")
        function _()
            ' VAlidate initial focus (focus has been set by capturing feature)
            focusedWidget = m.fwInstance.plugins.focus.getFocusedWidget()
            m.assertEqual(focusedWidget.id, "L1")
            ' Given: Framework is initialized with L1 focused
            l1Widget = m.fwInstance.getWidget("L1")
            m.assertNotInvalid(l1Widget)

            ' Then: Focus navigation should be enabled
            m.assertTrue(l1Widget.isFocusNavigationEnabled())
        end function

        @it("validates initial focus is on L1")
        function _()
            ' Given: Framework is initialized with initial focus on L1
            l1Widget = m.fwInstance.getWidget("L1")

            ' Then: Focus should be on L1
            focusedWidget = l1Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "L1")
            m.assertTrue(focusedWidget.viewModelState.isFocused)
        end function

        ' ======================================================================
        ' TEST SUITE 2: Directional Navigation (Global)
        ' ======================================================================

        @describe("directional navigation from L1")

        @it("stays on L1 when pressing left (edge of group)")
        function _()
            ' Given: Focus is on L1 (leftmost in GroupL2)
            l1Widget = m.fwInstance.getWidget("L1")

            ' When: Press left key (should stay or be captured)
            l1Widget.triggerKeyPress("left")

            ' Then: Focus should remain on L1 (no left neighbor)
            focusedWidget = l1Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "L1")
        end function

        @it("navigates from L1 up (if up direction configured)")
        function _()
            ' Given: Focus is on L1
            l1Widget = m.fwInstance.getWidget("L1")

            ' When: Press up key
            l1Widget.triggerKeyPress("up")

            ' Then: Focus should move per configuration (test what actually happens)
            focusedWidget = l1Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            ' Note: Adjust expectation based on template configuration
        end function

        @it("navigates from L1 down (if down direction configured)")
        function _()
            ' Given: Focus is on L1
            l1Widget = m.fwInstance.getWidget("L1")

            ' When: Press down key
            l1Widget.triggerKeyPress("down")

            ' Then: Focus should move per configuration (test what actually happens)
            focusedWidget = l1Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            ' Note: Adjust expectation based on template configuration
        end function

        ' ======================================================================
        ' TEST SUITE 3: Spatial Navigation Inside Inner Groups
        ' ======================================================================

        @describe("spatial navigation within GroupL2")

        @it("navigates from L1 right to L2")
        function _()
            ' Given: Focus is on L1 (set in beforeEach)
            l1Widget = m.fwInstance.getWidget("L1")

            ' When: Press right key
            l1Widget.triggerKeyPress("right")

            ' Then: Focus should move to L2
            focusedWidget = l1Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "L2")
            m.assertTrue(focusedWidget.viewModelState.isFocused)
        end function

        @it("navigates from L2 left back to L1")
        function _()
            ' Given: Focus is moved to L2
            l1Widget = m.fwInstance.getWidget("L1")
            l1Widget.setFocus("L2")

            ' When: Press left key
            l2Widget = m.fwInstance.getWidget("L2")
            l2Widget.triggerKeyPress("left")

            ' Then: Focus should move back to L1
            focusedWidget = l2Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "L1")
            m.assertTrue(focusedWidget.viewModelState.isFocused)
        end function

        @describe("spatial navigation within GroupR2")

        @it("navigates from R1 right to R2")
        function _()
            ' Given: Focus is moved to R1
            l1Widget = m.fwInstance.getWidget("L1")
            l1Widget.setFocus("R1")

            ' When: Press right key
            r1Widget = m.fwInstance.getWidget("R1")
            r1Widget.triggerKeyPress("right")

            ' Then: Focus should move to R2
            focusedWidget = r1Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "R2")
            m.assertTrue(focusedWidget.viewModelState.isFocused)
        end function

        @it("navigates from R2 left back to R1")
        function _()
            ' Given: Focus is moved to R2
            l1Widget = m.fwInstance.getWidget("L1")
            l1Widget.setFocus("R2")

            ' When: Press left key
            r2Widget = m.fwInstance.getWidget("R2")
            r2Widget.triggerKeyPress("left")

            ' Then: Focus should move back to R1
            focusedWidget = r2Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "R1")
            m.assertTrue(focusedWidget.viewModelState.isFocused)
        end function

        ' ======================================================================
        ' TEST SUITE 4: Focus Capturing (Inner Groups)
        ' ======================================================================

        @describe("focus capturing in GroupL2 with horizontal capture enabled")

        @it("captures left key from L1 - stays within GroupL2")
        function _()
            ' Given: Focus is on L1 (set in beforeEach)
            l1Widget = m.fwInstance.getWidget("L1")

            ' When: Press left key (should be captured if configured)
            l1Widget.triggerKeyPress("left")

            ' Then: Focus should remain on L1 (captured, no exit from group)
            focusedWidget = l1Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "L1")
        end function

        @it("captures right key from L2 - stays within GroupL2")
        function _()
            ' Given: Focus is moved to L2
            l1Widget = m.fwInstance.getWidget("L1")
            l1Widget.setFocus("L2")

            ' When: Press right key (should be captured if configured)
            l2Widget = m.fwInstance.getWidget("L2")
            l2Widget.triggerKeyPress("right")

            ' Then: Focus should remain on L2
            focusedWidget = l2Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "R1")
        end function

        @describe("focus capturing in GroupR2 with horizontal capture enabled")

        @it("captures left key from R1 - stays within GroupR2")
        function _()
            ' Given: Focus is moved to R1
            l1Widget = m.fwInstance.getWidget("L1")
            l1Widget.setFocus("R1")

            ' When: Press left key (should be captured if configured)
            r1Widget = m.fwInstance.getWidget("R1")
            r1Widget.triggerKeyPress("left")

            ' Then: Focus should remain on R1
            focusedWidget = r1Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "R1")
        end function

        @it("captures right key from R2 - stays within GroupR2")
        function _()
            ' Given: Focus is moved to R2
            l1Widget = m.fwInstance.getWidget("L1")
            l1Widget.setFocus("R2")

            ' When: Press right key (should be captured if configured)
            r2Widget = m.fwInstance.getWidget("R2")
            r2Widget.triggerKeyPress("right")

            ' Then: Focus should remain on R2
            focusedWidget = r2Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "R2")
        end function

        ' ======================================================================
        ' TEST SUITE 5: Focus Bubbling (Depth 3 to Top)
        ' ======================================================================

        @describe("focus bubbling from inner groups")

        @it("bubbles from L1 up (per group configuration)")
        function _()
            ' Given: Focus is on L1 (set in beforeEach)
            l1Widget = m.fwInstance.getWidget("L1")

            ' When: Press up key
            l1Widget.triggerKeyPress("up")

            ' Then: Focus should bubble per GroupL2.up configuration
            focusedWidget = l1Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            ' Note: Verify based on actual template configuration
        end function

        @it("bubbles from L2 up (per group configuration)")
        function _()
            ' Given: Focus is moved to L2
            l1Widget = m.fwInstance.getWidget("L1")
            l1Widget.setFocus("L2")

            ' When: Press up key
            l2Widget = m.fwInstance.getWidget("L2")
            l2Widget.triggerKeyPress("up")

            ' Then: Focus should bubble per GroupL2.up configuration
            focusedWidget = l2Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            ' Note: Verify based on actual template configuration
        end function

        @it("bubbles from R1 up (per group configuration)")
        function _()
            ' Given: Focus is moved to R1
            l1Widget = m.fwInstance.getWidget("L1")
            l1Widget.setFocus("R1")

            ' When: Press up key
            r1Widget = m.fwInstance.getWidget("R1")
            r1Widget.triggerKeyPress("up")

            ' Then: Focus should bubble per GroupR2.up configuration
            focusedWidget = r1Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            ' Note: Verify based on actual template configuration
        end function

        @it("bubbles from R2 up (per group configuration)")
        function _()
            ' Given: Focus is moved to R2
            l1Widget = m.fwInstance.getWidget("L1")
            l1Widget.setFocus("R2")

            ' When: Press up key
            r2Widget = m.fwInstance.getWidget("R2")
            r2Widget.triggerKeyPress("up")

            ' Then: Focus should bubble per GroupR2.up configuration
            focusedWidget = r2Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            ' Note: Verify based on actual template configuration
        end function

        ' ======================================================================
        ' TEST SUITE 6: Node Tree Structure Validation
        ' ======================================================================

        @describe("focus test template produces expected node tree")

        @it("creates expected nodes in native tree")
        function _()
            ' Given: Framework is initialized
            rootWidget = m.fwInstance.getRootWidget()
            m.assertNotInvalid(rootWidget)

            ' Then: Validate topWidget group structure
            topWidget = rootWidget.children.topWidget
            m.assertNotInvalid(topWidget)
            m.assertEqual(topWidget.id, "topWidget")

            ' Validate left branch structure (GroupL -> GroupL2 -> L1, L2)
            groupL = m.fwInstance.getWidget("GroupL")
            m.assertNotInvalid(groupL)
            m.assertEqual(groupL.id, "GroupL")

            groupL2 = m.fwInstance.getWidget("GroupL2")
            m.assertNotInvalid(groupL2)
            m.assertEqual(groupL2.id, "GroupL2")

            l1 = m.fwInstance.getWidget("L1")
            m.assertNotInvalid(l1)
            m.assertEqual(l1.id, "L1")
            m.assertEqual(l1.node.subtype(), "Rectangle")

            l2 = m.fwInstance.getWidget("L2")
            m.assertNotInvalid(l2)
            m.assertEqual(l2.id, "L2")
            m.assertEqual(l2.node.subtype(), "Rectangle")

            ' Validate right branch structure (GroupR -> GroupR2 -> R1, R2)
            groupR = m.fwInstance.getWidget("GroupR")
            m.assertNotInvalid(groupR)
            m.assertEqual(groupR.id, "GroupR")

            groupR2 = m.fwInstance.getWidget("GroupR2")
            m.assertNotInvalid(groupR2)
            m.assertEqual(groupR2.id, "GroupR2")

            r1 = m.fwInstance.getWidget("R1")
            m.assertNotInvalid(r1)
            m.assertEqual(r1.id, "R1")
            m.assertEqual(r1.node.subtype(), "Rectangle")

            r2 = m.fwInstance.getWidget("R2")
            m.assertNotInvalid(r2)
            m.assertEqual(r2.id, "R2")
            m.assertEqual(r2.node.subtype(), "Rectangle")
        end function

        ' ======================================================================
        ' TEST SUITE 7: Deep Search for defaultFocusId
        ' ======================================================================

        @describe("deep search for defaultFocusId - focusItem 3 levels down")

        @it("finds DeepTarget 3 levels down when setting focus on DeepSearchGroup")
        function _()
            ' Given: DeepSearchGroup has defaultFocusId: "DeepTarget" which is 3 levels deep
            deepSearchGroup = m.fwInstance.getWidget("DeepSearchGroup")
            m.assertNotInvalid(deepSearchGroup)

            ' When: Set focus on DeepSearchGroup (should trigger capturing with deep search)
            deepSearchGroup.setFocus("DeepSearchGroup")

            ' Then: Focus should be on DeepTarget (3 levels down)
            focusedWidget = deepSearchGroup.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "DeepTarget")
            m.assertTrue(focusedWidget.viewModelState.isFocused)
        end function

        @it("validates DeepTarget exists in the widget tree")
        function _()
            ' Given: Framework is initialized
            deepTarget = m.fwInstance.getWidget("DeepTarget")
            m.assertNotInvalid(deepTarget)
            m.assertEqual(deepTarget.id, "DeepTarget")
            m.assertEqual(deepTarget.node.subtype(), "Rectangle")
        end function

        @it("can navigate from DeepTarget to DeepSibling")
        function _()
            ' Given: Focus is on DeepTarget
            deepSearchGroup = m.fwInstance.getWidget("DeepSearchGroup")
            deepSearchGroup.setFocus("DeepTarget")

            ' When: Press right key (spatial navigation)
            deepTarget = m.fwInstance.getWidget("DeepTarget")
            deepTarget.triggerKeyPress("right")

            ' Then: Focus should move to DeepSibling
            focusedWidget = deepTarget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "DeepSibling")
        end function

        @describe("deep search for defaultFocusId - nested group with fallback")

        @it("finds nested group and applies its fallback (FinalTarget)")
        function _()
            ' Given: NestedGroupTestParent has defaultFocusId: "NestedTargetGroup" (a group 2 levels down)
            '        NestedTargetGroup has defaultFocusId: "FinalTarget"
            nestedGroupTestParent = m.fwInstance.getWidget("NestedGroupTestParent")
            m.assertNotInvalid(nestedGroupTestParent)

            ' When: Set focus on NestedGroupTestParent
            nestedGroupTestParent.setFocus("NestedGroupTestParent")

            ' Then: Focus should be on FinalTarget (via NestedTargetGroup fallback)
            focusedWidget = nestedGroupTestParent.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "FinalTarget")
            m.assertTrue(focusedWidget.viewModelState.isFocused)
        end function

        @it("validates NestedTargetGroup exists in the widget tree")
        function _()
            ' Given: Framework is initialized
            nestedTargetGroup = m.fwInstance.getWidget("NestedTargetGroup")
            m.assertNotInvalid(nestedTargetGroup)
            m.assertEqual(nestedTargetGroup.id, "NestedTargetGroup")
        end function

        @it("can navigate within NestedTargetGroup")
        function _()
            ' Given: Focus is on FinalTarget
            nestedGroupTestParent = m.fwInstance.getWidget("NestedGroupTestParent")
            nestedGroupTestParent.setFocus("FinalTarget")

            ' When: Press right key (spatial navigation)
            finalTarget = m.fwInstance.getWidget("FinalTarget")
            finalTarget.triggerKeyPress("right")

            ' Then: Focus should move to FinalSibling
            focusedWidget = finalTarget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "FinalSibling")
        end function

        @describe("deep search edge cases")

        @it("deep search does not break existing direct child behavior")
        function _()
            ' Given: GroupL2 has defaultFocusId: "L1" (direct child)
            groupL2 = m.fwInstance.getWidget("GroupL2")
            m.assertNotInvalid(groupL2)

            ' When: Set focus on GroupL2
            groupL2.setFocus("GroupL2")

            ' Then: Focus should be on L1 (existing behavior preserved)
            focusedWidget = groupL2.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "L1")
        end function

        @it("spatial navigation still works in deep hierarchies")
        function _()
            ' Given: Focus is on DeepTarget
            deepSearchGroup = m.fwInstance.getWidget("DeepSearchGroup")
            deepSearchGroup.setFocus("DeepTarget")

            deepTarget = m.fwInstance.getWidget("DeepTarget")

            ' When: Press right then left
            deepTarget.triggerKeyPress("right")
            deepSibling = m.fwInstance.getWidget("DeepSibling")
            deepSibling.triggerKeyPress("left")

            ' Then: Focus should return to DeepTarget
            focusedWidget = deepSibling.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "DeepTarget")
        end function

        ' ======================================================================
        ' TEST SUITE 8: Spatial Navigation Edge Cases
        ' ======================================================================

        @describe("spatial navigation edge cases")

        @it("handles navigation with empty neighbor list")
        function _()
            ' Given: Focus is on L1
            l1Widget = m.fwInstance.getWidget("L1")

            ' When: Press up (no spatial neighbor above)
            l1Widget.triggerKeyPress("up")

            ' Then: Should either stay or bubble up per configuration
            focusedWidget = l1Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
        end function

        @it("navigates correctly when items are at same position")
        function _()
            ' Given: L1 and L2 are at same Y coordinate
            l1Widget = m.fwInstance.getWidget("L1")

            ' When: Navigate right from L1
            l1Widget.triggerKeyPress("right")

            ' Then: Should move to L2 (spatial navigation right)
            focusedWidget = l1Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "L2")
        end function

        @it("handles circular navigation within group")
        function _()
            ' Given: Focus on L2 (rightmost in GroupL2)
            l1Widget = m.fwInstance.getWidget("L1")
            l1Widget.setFocus("L2")

            ' When: Press right (should be captured by group)
            l2Widget = m.fwInstance.getWidget("L2")
            l2Widget.triggerKeyPress("right")

            ' Then: Should stay on L2 (captured by group)
            focusedWidget = l2Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "R1")
        end function

        ' ======================================================================
        ' TEST SUITE 9: Bubbling Focus Advanced
        ' ======================================================================

        @describe("bubbling focus advanced scenarios")

        @it("bubbles through multiple group levels")
        function _()
            ' Given: Focus is on L1 (3 levels deep)
            l1Widget = m.fwInstance.getWidget("L1")

            ' When: Press down (should bubble up to topWidget group)
            l1Widget.triggerKeyPress("down")

            ' Then: Should bubble and handle per topWidget configuration
            focusedWidget = l1Widget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
        end function

        @it("bubbling respects custom navigation rules")
        function _()
            ' Given: topWidget has custom right navigation to GroupR2
            topWidget = m.fwInstance.getWidget("topWidget")
            topWidget.setFocus()

            ' When: Press right from topWidget
            topWidget.triggerKeyPress("right")

            ' Then: Should navigate to R1 (via GroupR2 defaultFocusId)
            focusedWidget = topWidget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "L2")
        end function

        ' ======================================================================
        ' TEST SUITE 10: Capturing Focus Advanced
        ' ======================================================================

        @describe("capturing focus advanced scenarios")

        @it("capturing resolves group to focusItem correctly")
        function _()
            ' Given: topWidget has defaultFocusId pointing to GroupL2
            topWidget = m.fwInstance.getWidget("topWidget")

            ' When: Set focus on topWidget (should capture to L1 via GroupL2)
            topWidget.setFocus()

            ' Then: Focus should be on L1
            focusedWidget = topWidget.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "L1")
        end function

        @describe("focus plugin utility methods")

        @it("getFocusedWidget returns currently focused widget")
        function _()
            ' Given: L1 is focused (set in beforeEach)
            focusPlugin = m.fwInstance.plugins.focus

            ' When: Get focused widget
            focusedWidget = focusPlugin.getFocusedWidget()

            ' Then: Should return L1 widget
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "L1")
        end function

        @it("findAncestorGroups returns empty array for top-level widget")
        function _()
            ' Given: topWidget has no ancestor groups
            topWidget = m.fwInstance.getWidget("topWidget")
            focusPlugin = m.fwInstance.plugins.focus

            ' When: Find ancestor groups for topWidget HID
            ancestorGroups = focusPlugin.findAncestorGroups(topWidget.HID)

            ' Then: Should return empty array (no ancestors)
            m.assertNotInvalid(ancestorGroups)
            m.assertEqual(ancestorGroups.Count(), 0)
        end function

        @it("findAncestorGroups returns parent group for child widget")
        function _()
            ' Given: L1 is inside GroupL2
            l1Widget = m.fwInstance.getWidget("L1")
            focusPlugin = m.fwInstance.plugins.focus

            ' When: Find ancestor groups for L1
            ancestorGroups = focusPlugin.findAncestorGroups(l1Widget.HID)

            ' Then: Should include GroupL2
            m.assertNotInvalid(ancestorGroups)
            m.assertTrue(ancestorGroups.Count() > 0)
        end function

        @describe("focus navigation toggle")

        @it("enableFocusNavigation enables navigation via widget decorator")
        function _()
            ' Given: L1 widget
            l1Widget = m.fwInstance.getWidget("L1")

            ' When: Enable navigation via widget decorator
            l1Widget.enableFocusNavigation(true)

            ' Then: Navigation should be enabled
            m.assertTrue(l1Widget.isFocusNavigationEnabled())
        end function

        @it("enableFocusNavigation disables navigation via widget decorator")
        function _()
            ' Given: L1 widget with navigation enabled
            l1Widget = m.fwInstance.getWidget("L1")
            l1Widget.enableFocusNavigation(true)

            ' When: Disable navigation
            l1Widget.enableFocusNavigation(false)

            ' Then: Navigation should be disabled
            m.assertFalse(l1Widget.isFocusNavigationEnabled())
        end function

        @it("isFocusNavigationEnabled returns current state via widget decorator")
        function _()
            ' Given: L1 widget
            l1Widget = m.fwInstance.getWidget("L1")

            ' When: Check initial state
            isEnabled = l1Widget.isFocusNavigationEnabled()

            ' Then: Should return boolean
            m.assertNotInvalid(isEnabled)
        end function

        @describe("setFocus edge cases")

        @it("setFocus returns false for invalid ref")
        function _()
            ' Given: Focus plugin
            focusPlugin = m.fwInstance.plugins.focus

            ' When: Try to set focus with invalid ref
            result = focusPlugin.setFocus(invalid)

            ' Then: Should return false
            m.assertFalse(result)
        end function

        @it("setFocus returns false for empty string ref")
        function _()
            ' Given: Focus plugin
            focusPlugin = m.fwInstance.plugins.focus

            ' When: Try to set focus with empty string
            result = focusPlugin.setFocus("")

            ' Then: Should return false
            m.assertFalse(result)
        end function

        @it("setFocus returns false for non-existent widget id")
        function _()
            ' Given: Focus plugin
            focusPlugin = m.fwInstance.plugins.focus

            ' When: Try to set focus with non-existent id
            result = focusPlugin.setFocus("nonExistentWidget123")

            ' Then: Should return false
            m.assertFalse(result)
        end function

        @it("setFocus returns false when already focused")
        function _()
            ' Given: L1 is already focused (set in beforeEach)
            l1Widget = m.fwInstance.getWidget("L1")
            focusPlugin = m.fwInstance.plugins.focus

            ' When: Try to set focus to L1 again
            result = l1Widget.setFocus()

            ' Then: Should return false (no change)
            m.assertFalse(result)
        end function

        ' ======================================================================
        ' TEST SUITE 11: Focus Callbacks (onFocus, onBlur, onSelect)
        ' ======================================================================

        @describe("focus callbacks")

        @it("onFocus callback is called when widget gains focus")
        function _()
            ' Given: A widget with onFocus callback
            onFocusCalled = { value: false }
            template = {
                id: "callbackTestRoot",
                nodeType: "Group",
                focusGroup: { defaultFocusId: "focusCallbackItem" },
                children: [
                    {
                        id: "focusCallbackItem",
                        nodeType: "Rectangle",
                        fields: { width: 100, height: 50 },
                        focus: {
                            onFocus: sub()
                                m.testMarker = "onFocus_called"
                            end sub
                        }
                    }
                ]
            }

            ' Destroy existing and create new framework with callback template
            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            ' When: Set focus on the item
            widget = m.fwInstance.getWidget("focusCallbackItem")
            widget.setFocus()

            ' Then: onFocus should have been called
            m.assertEqual(widget.testMarker, "onFocus_called")
        end function

        @it("onBlur callback is called when widget loses focus")
        function _()
            ' Given: Two widgets, one with onBlur callback
            template = {
                id: "blurTestRoot",
                nodeType: "Group",
                focusGroup: { defaultFocusId: "blurItem1" },
                children: [
                    {
                        id: "blurItem1",
                        nodeType: "Rectangle",
                        fields: { width: 100, height: 50, translation: [0, 0] },
                        focus: {
                            onBlur: sub()
                                m.testMarker = "onBlur_called"
                            end sub
                        }
                    },
                    {
                        id: "blurItem2",
                        nodeType: "Rectangle",
                        fields: { width: 100, height: 50, translation: [150, 0] },
                        focus: {}
                    }
                ]
            }

            ' Destroy existing and create new framework
            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            ' Set initial focus
            widget1 = m.fwInstance.getWidget("blurItem1")
            widget1.setFocus()

            ' Verify initial state
            m.assertInvalid(widget1.testMarker)

            ' When: Move focus to second item
            widget1.setFocus("blurItem2")

            ' Then: onBlur should have been called on first widget
            m.assertEqual(widget1.testMarker, "onBlur_called")
        end function

        @it("onSelect callback is called when OK is pressed")
        function _()
            ' Given: A widget with onSelect callback
            template = {
                id: "selectTestRoot",
                nodeType: "Group",
                focusGroup: { defaultFocusId: "selectItem" },
                children: [
                    {
                        id: "selectItem",
                        nodeType: "Rectangle",
                        fields: { width: 100, height: 50 },
                        focus: {
                            onSelect: sub()
                                m.testMarker = "onSelect_called"
                            end sub
                        }
                    }
                ]
            }

            ' Destroy existing and create new framework
            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            ' Set focus
            widget = m.fwInstance.getWidget("selectItem")
            widget.setFocus()

            ' Verify initial state
            m.assertInvalid(widget.testMarker)

            ' When: Press OK key
            widget.triggerKeyPress("OK")

            ' Then: onSelect should have been called
            m.assertEqual(widget.testMarker, "onSelect_called")
        end function

        @it("onFocusChanged callback is called with isFocused parameter")
        function _()
            ' Given: A widget with onFocusChanged callback
            template = {
                id: "focusChangedTestRoot",
                nodeType: "Group",
                focusGroup: { defaultFocusId: "focusChangedItem1" },
                children: [
                    {
                        id: "focusChangedItem1",
                        nodeType: "Rectangle",
                        fields: { width: 100, height: 50, translation: [0, 0] },
                        focus: {
                            onFocusChanged: sub(isFocused as boolean)
                                m.lastFocusState = isFocused
                            end sub
                        }
                    },
                    {
                        id: "focusChangedItem2",
                        nodeType: "Rectangle",
                        fields: { width: 100, height: 50, translation: [150, 0] },
                        focus: {}
                    }
                ]
            }

            ' Destroy existing and create new framework
            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            ' When: Set focus on first item
            widget1 = m.fwInstance.getWidget("focusChangedItem1")
            widget1.setFocus()

            ' Then: onFocusChanged should be called with true
            m.assertTrue(widget1.lastFocusState)

            ' When: Move focus to second item
            widget1.setFocus("focusChangedItem2")

            ' Then: onFocusChanged should be called with false
            m.assertFalse(widget1.lastFocusState)
        end function

        @it("both onFocus and onBlur are called during focus transition")
        function _()
            ' Given: Two widgets with onFocus and onBlur callbacks
            template = {
                id: "transitionTestRoot",
                nodeType: "Group",
                focusGroup: { defaultFocusId: "transitionItem1" },
                children: [
                    {
                        id: "transitionItem1",
                        nodeType: "Rectangle",
                        fields: { width: 100, height: 50, translation: [0, 0] },
                        focus: {
                            onFocus: sub()
                                m.focusCount = (m.focusCount ?? 0) + 1
                            end sub,
                            onBlur: sub()
                                m.blurCount = (m.blurCount ?? 0) + 1
                            end sub
                        }
                    },
                    {
                        id: "transitionItem2",
                        nodeType: "Rectangle",
                        fields: { width: 100, height: 50, translation: [150, 0] },
                        focus: {
                            onFocus: sub()
                                m.focusCount = (m.focusCount ?? 0) + 1
                            end sub,
                            onBlur: sub()
                                m.blurCount = (m.blurCount ?? 0) + 1
                            end sub
                        }
                    }
                ]
            }

            ' Destroy existing and create new framework
            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            widget1 = m.fwInstance.getWidget("transitionItem1")
            widget2 = m.fwInstance.getWidget("transitionItem2")

            ' When: Set focus on first item
            widget1.setFocus()

            ' Then: widget1 onFocus called
            m.assertEqual(widget1.focusCount, 1)
            m.assertInvalid(widget1.blurCount)

            ' When: Move focus to second item
            widget1.setFocus("transitionItem2")

            ' Then: widget1 onBlur called, widget2 onFocus called
            m.assertEqual(widget1.blurCount, 1)
            m.assertEqual(widget2.focusCount, 1)
        end function

        ' ======================================================================
        ' TEST SUITE 12: setGroupLastFocusedId
        ' ======================================================================

        @describe("setGroupLastFocusedId method")

        @it("updates lastFocusedHID when called on a focus group")
        function _()
            ' Given: GroupL2 is a focus group with L1 and L2 items
            groupL2 = m.fwInstance.getWidget("GroupL2")
            focusPlugin = m.fwInstance.plugins.focus

            ' Get the group from the stack
            group = focusPlugin.groupStack.get(groupL2.HID)
            m.assertNotInvalid(group)

            ' When: Call setGroupLastFocusedId with L2's id on the group widget
            groupL2.setGroupLastFocusedId("L2")

            ' Then: The group's lastFocusedHID should be updated to L2's HID
            l2Widget = m.fwInstance.getWidget("L2")
            m.assertEqual(group.lastFocusedHID, l2Widget.HID)
        end function

        @it("updates parent group's lastFocusedHID when called on a focus item")
        function _()
            ' Given: L1 is a focus item inside GroupL2
            l1Widget = m.fwInstance.getWidget("L1")
            focusPlugin = m.fwInstance.plugins.focus

            ' Get the parent group (GroupL2) from the stack
            groupL2Widget = m.fwInstance.getWidget("GroupL2")
            group = focusPlugin.groupStack.get(groupL2Widget.HID)
            m.assertNotInvalid(group)

            ' When: Call setGroupLastFocusedId with L2's id on L1 (a sibling focus item)
            l1Widget.setGroupLastFocusedId("L2")

            ' Then: The parent group's lastFocusedHID should be updated to L2's HID
            l2Widget = m.fwInstance.getWidget("L2")
            m.assertEqual(group.lastFocusedHID, l2Widget.HID)
        end function

        @it("does nothing when called with non-existent id")
        function _()
            ' Given: GroupL2 with initial lastFocusedHID
            groupL2 = m.fwInstance.getWidget("GroupL2")
            focusPlugin = m.fwInstance.plugins.focus

            group = focusPlugin.groupStack.get(groupL2.HID)
            initialLastFocusedHID = group.lastFocusedHID

            ' When: Call setGroupLastFocusedId with non-existent id
            groupL2.setGroupLastFocusedId("nonExistentWidget")

            ' Then: lastFocusedHID should remain unchanged
            m.assertEqual(group.lastFocusedHID, initialLastFocusedHID)
        end function

        @it("resolves id from focusItemStack")
        function _()
            ' Given: L1 is a focus item
            groupL2 = m.fwInstance.getWidget("GroupL2")
            focusPlugin = m.fwInstance.plugins.focus

            group = focusPlugin.groupStack.get(groupL2.HID)
            m.assertNotInvalid(group)

            ' When: Call setGroupLastFocusedId with L1's id (a focus item)
            groupL2.setGroupLastFocusedId("L1")

            ' Then: The group's lastFocusedHID should be updated to L1's HID
            l1Widget = m.fwInstance.getWidget("L1")
            m.assertEqual(group.lastFocusedHID, l1Widget.HID)
        end function

        @it("resolves id from groupStack when not found in focusItemStack")
        function _()
            ' Given: GroupL2 is a group (not a focus item)
            topWidget = m.fwInstance.getWidget("topWidget")
            focusPlugin = m.fwInstance.plugins.focus

            topGroup = focusPlugin.groupStack.get(topWidget.HID)
            m.assertNotInvalid(topGroup)

            ' When: Call setGroupLastFocusedId with GroupL2's id (a group)
            topWidget.setGroupLastFocusedId("GroupL2")

            ' Then: The top group's lastFocusedHID should be updated to GroupL2's HID
            groupL2Widget = m.fwInstance.getWidget("GroupL2")
            m.assertEqual(topGroup.lastFocusedHID, groupL2Widget.HID)
        end function

        ' ======================================================================
        ' TEST SUITE 13: trackDescendantFocus (Deep Focus Memory)
        ' ======================================================================

        @describe("trackDescendantFocus - deep focus memory")

        @it("ancestor group with trackDescendantFocus stores deeply nested focus item HID")
        function _()
            ' Given: A template with trackDescendantFocus: true on the outer group
            template = {
                id: "rememberTestRoot",
                nodeType: "Group",
                focusGroup: {
                    defaultFocusId: "outerGroup"
                },
                children: [
                    {
                        id: "outerGroup",
                        nodeType: "Group",
                        fields: { translation: [0, 0] },
                        focusGroup: {
                            defaultFocusId: "innerGroup",
                            trackDescendantFocus: true
                        },
                        children: [
                            {
                                id: "innerGroup",
                                nodeType: "Group",
                                fields: { translation: [0, 0] },
                                focusGroup: {
                                    defaultFocusId: "deepItem1"
                                },
                                children: [
                                    {
                                        id: "deepItem1",
                                        nodeType: "Rectangle",
                                        fields: { width: 100, height: 50, translation: [0, 0] },
                                        focus: {}
                                    },
                                    {
                                        id: "deepItem2",
                                        nodeType: "Rectangle",
                                        fields: { width: 100, height: 50, translation: [150, 0] },
                                        focus: {}
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        id: "otherItem",
                        nodeType: "Rectangle",
                        fields: { width: 100, height: 50, translation: [0, 200] },
                        focus: {}
                    }
                ]
            }

            ' Destroy existing and create new framework
            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            focusPlugin = m.fwInstance.plugins.focus

            ' Step 1: Focus deepItem2 (nested 2 levels deep)
            deepItem2 = m.fwInstance.getWidget("deepItem2")
            deepItem2.setFocus()

            ' Step 2: Move focus away to trigger blur (lastFocusedHID is set on blur)
            otherItem = m.fwInstance.getWidget("otherItem")
            otherItem.setFocus()

            ' Get the outer group
            outerGroupWidget = m.fwInstance.getWidget("outerGroup")
            outerGroup = focusPlugin.groupStack.get(outerGroupWidget.HID)

            ' Then: outer group should remember deepItem2's HID (because trackDescendantFocus: true)
            m.assertEqual(outerGroup.lastFocusedHID, deepItem2.HID)
        end function

        @it("returns to deeply remembered focus item when re-entering group")
        function _()
            ' Given: Template with trackDescendantFocus on outer group
            template = {
                id: "returnTestRoot",
                nodeType: "Group",
                focusGroup: {
                    defaultFocusId: "outerGroup"
                },
                children: [
                    {
                        id: "outerGroup",
                        nodeType: "Group",
                        fields: { translation: [0, 0] },
                        focusGroup: {
                            defaultFocusId: "innerGroup",
                            trackDescendantFocus: true,
                            down: "exitGroup"
                        },
                        children: [
                            {
                                id: "innerGroup",
                                nodeType: "Group",
                                fields: { translation: [0, 0] },
                                focusGroup: {
                                    defaultFocusId: "nestedItem1"
                                },
                                children: [
                                    {
                                        id: "nestedItem1",
                                        nodeType: "Rectangle",
                                        fields: { width: 100, height: 50, translation: [0, 0] },
                                        focus: {}
                                    },
                                    {
                                        id: "nestedItem2",
                                        nodeType: "Rectangle",
                                        fields: { width: 100, height: 50, translation: [150, 0] },
                                        focus: {}
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        id: "exitGroup",
                        nodeType: "Group",
                        fields: { translation: [0, 200] },
                        focusGroup: {
                            defaultFocusId: "exitItem",
                            up: "outerGroup"
                        },
                        children: [
                            {
                                id: "exitItem",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 50, translation: [0, 0] },
                                focus: {}
                            }
                        ]
                    }
                ]
            }

            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            ' Step 1: Focus nestedItem2 (deep in hierarchy)
            nestedItem2 = m.fwInstance.getWidget("nestedItem2")
            nestedItem2.setFocus()

            ' Step 2: Navigate away (exit to exitGroup -> exitItem)
            nestedItem2.triggerKeyPress("down")

            ' Verify we're now on exitItem
            focusedWidget = m.fwInstance.plugins.focus.getFocusedWidget()
            m.assertEqual(focusedWidget.id, "exitItem")

            ' Step 3: Navigate back up to outerGroup
            exitItem = m.fwInstance.getWidget("exitItem")
            exitItem.triggerKeyPress("up")

            ' Then: Focus should return to nestedItem2 (deeply remembered)
            focusedWidget = m.fwInstance.plugins.focus.getFocusedWidget()
            m.assertEqual(focusedWidget.id, "nestedItem2")
        end function

        @it("immediate parent always stores lastFocusedHID regardless of trackDescendantFocus")
        function _()
            ' Given: Template where immediate parent does NOT have trackDescendantFocus
            template = {
                id: "immediateParentTestRoot",
                nodeType: "Group",
                focusGroup: {
                    defaultFocusId: "parentGroup"
                },
                children: [
                    {
                        id: "parentGroup",
                        nodeType: "Group",
                        fields: { translation: [0, 0] },
                        focusGroup: {
                            defaultFocusId: "childItem1"
                            ' Note: NO trackDescendantFocus here
                        },
                        children: [
                            {
                                id: "childItem1",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 50, translation: [0, 0] },
                                focus: {}
                            },
                            {
                                id: "childItem2",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 50, translation: [150, 0] },
                                focus: {}
                            }
                        ]
                    },
                    {
                        id: "outsideItem",
                        nodeType: "Rectangle",
                        fields: { width: 100, height: 50, translation: [0, 200] },
                        focus: {}
                    }
                ]
            }

            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            focusPlugin = m.fwInstance.plugins.focus

            ' Step 1: Focus childItem2
            childItem2 = m.fwInstance.getWidget("childItem2")
            childItem2.setFocus()

            ' Step 2: Move focus away to trigger blur (lastFocusedHID is set on blur)
            outsideItem = m.fwInstance.getWidget("outsideItem")
            outsideItem.setFocus()

            ' Then: Immediate parent should still store lastFocusedHID (default behavior)
            parentGroupWidget = m.fwInstance.getWidget("parentGroup")
            parentGroup = focusPlugin.groupStack.get(parentGroupWidget.HID)
            m.assertEqual(parentGroup.lastFocusedHID, childItem2.HID)
        end function

        @it("ancestor without trackDescendantFocus does NOT store deeply nested HID")
        function _()
            ' Given: Outer group without trackDescendantFocus, inner group with items
            template = {
                id: "noRememberTestRoot",
                nodeType: "Group",
                focusGroup: {
                    defaultFocusId: "outerGroup"
                    ' Note: NO trackDescendantFocus
                },
                children: [
                    {
                        id: "outerGroup",
                        nodeType: "Group",
                        fields: { translation: [0, 0] },
                        focusGroup: {
                            defaultFocusId: "innerGroup"
                            ' Note: NO trackDescendantFocus
                        },
                        children: [
                            {
                                id: "innerGroup",
                                nodeType: "Group",
                                fields: { translation: [0, 0] },
                                focusGroup: {
                                    defaultFocusId: "item1"
                                },
                                children: [
                                    {
                                        id: "item1",
                                        nodeType: "Rectangle",
                                        fields: { width: 100, height: 50, translation: [0, 0] },
                                        focus: {}
                                    },
                                    {
                                        id: "item2",
                                        nodeType: "Rectangle",
                                        fields: { width: 100, height: 50, translation: [150, 0] },
                                        focus: {}
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        id: "outsideItem",
                        nodeType: "Rectangle",
                        fields: { width: 100, height: 50, translation: [0, 200] },
                        focus: {}
                    }
                ]
            }

            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            focusPlugin = m.fwInstance.plugins.focus

            ' Step 1: Focus item2 (nested inside innerGroup)
            item2 = m.fwInstance.getWidget("item2")
            item2.setFocus()

            ' Step 2: Move focus away to trigger blur (lastFocusedHID is set on blur)
            outsideItem = m.fwInstance.getWidget("outsideItem")
            outsideItem.setFocus()

            ' Then: outerGroup should NOT remember item2 (no trackDescendantFocus)
            outerGroupWidget = m.fwInstance.getWidget("outerGroup")
            outerGroup = focusPlugin.groupStack.get(outerGroupWidget.HID)
            m.assertEqual(outerGroup.lastFocusedHID, "")

            ' But innerGroup (immediate parent) SHOULD remember
            innerGroupWidget = m.fwInstance.getWidget("innerGroup")
            innerGroup = focusPlugin.groupStack.get(innerGroupWidget.HID)
            m.assertEqual(innerGroup.lastFocusedHID, item2.HID)
        end function

        @it("trackDescendantFocus defaults to false")
        function _()
            ' Given: A group without explicit trackDescendantFocus setting
            template = {
                id: "defaultTestRoot",
                nodeType: "Group",
                focusGroup: {
                    defaultFocusId: "testItem"
                },
                children: [
                    {
                        id: "testItem",
                        nodeType: "Rectangle",
                        fields: { width: 100, height: 50 },
                        focus: {}
                    }
                ]
            }

            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            focusPlugin = m.fwInstance.plugins.focus

            ' When: Get the group from stack
            rootWidget = m.fwInstance.getWidget("defaultTestRoot")
            group = focusPlugin.groupStack.get(rootWidget.HID)

            ' Then: trackDescendantFocus should default to false
            m.assertFalse(group.trackDescendantFocus)
        end function

        ' ======================================================================
        ' TEST SUITE 14: enableSpatialEnter
        ' ======================================================================

        @describe("enableSpatialEnter - spatial group entry")

        @it("enters group at geometrically closest item instead of defaultFocusId")
        function _()
            ' Given: Two groups side by side
            '   sourceGroup on the left with sourceTop (y=0) and sourceBottom (y=200)
            '   targetGroup on the right with enableSpatialEnter: true,
            '     defaultFocusId: "targetTop", targetTop (y=0), targetBottom (y=200)
            '
            ' When focus is on sourceBottom and we navigate right,
            ' enableSpatialEnter should pick targetBottom (closest) instead of targetTop (default)
            template = {
                id: "spatialEnterRoot",
                nodeType: "Group",
                focusGroup: {
                    defaultFocusId: "sourceGroup"
                },
                children: [
                    {
                        id: "sourceGroup",
                        nodeType: "Group",
                        fields: { translation: [0, 0] },
                        focusGroup: {
                            defaultFocusId: "sourceTop",
                            right: "targetGroup"
                        },
                        children: [
                            {
                                id: "sourceTop",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 0] },
                                focus: {}
                            },
                            {
                                id: "sourceBottom",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 200] },
                                focus: {}
                            }
                        ]
                    },
                    {
                        id: "targetGroup",
                        nodeType: "Group",
                        fields: { translation: [300, 0] },
                        focusGroup: {
                            defaultFocusId: "targetTop",
                            enableSpatialEnter: true,
                            left: "sourceGroup"
                        },
                        children: [
                            {
                                id: "targetTop",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 0] },
                                focus: {}
                            },
                            {
                                id: "targetBottom",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 200] },
                                focus: {}
                            }
                        ]
                    }
                ]
            }

            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            ' Focus sourceBottom
            sourceBottom = m.fwInstance.getWidget("sourceBottom")
            sourceBottom.setFocus()

            ' When: Press right to enter targetGroup
            sourceBottom.triggerKeyPress("right")

            ' Then: Focus should be on targetBottom (spatially closest), not targetTop (default)
            focusedWidget = m.fwInstance.plugins.focus.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "targetBottom")
        end function

        @it("enters group at default item when focus is closest to it")
        function _()
            ' Given: Same layout, but focus is on sourceTop (y=0)
            ' targetTop is at y=0, targetBottom at y=200
            ' So targetTop (the default) is also the closest
            template = {
                id: "spatialEnterDefaultRoot",
                nodeType: "Group",
                focusGroup: {
                    defaultFocusId: "sourceGroup"
                },
                children: [
                    {
                        id: "sourceGroup",
                        nodeType: "Group",
                        fields: { translation: [0, 0] },
                        focusGroup: {
                            defaultFocusId: "sourceTop",
                            right: "targetGroup"
                        },
                        children: [
                            {
                                id: "sourceTop",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 0] },
                                focus: {}
                            },
                            {
                                id: "sourceBottom",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 200] },
                                focus: {}
                            }
                        ]
                    },
                    {
                        id: "targetGroup",
                        nodeType: "Group",
                        fields: { translation: [300, 0] },
                        focusGroup: {
                            defaultFocusId: "targetTop",
                            enableSpatialEnter: true,
                            left: "sourceGroup"
                        },
                        children: [
                            {
                                id: "targetTop",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 0] },
                                focus: {}
                            },
                            {
                                id: "targetBottom",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 200] },
                                focus: {}
                            }
                        ]
                    }
                ]
            }

            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            ' Focus sourceTop
            sourceTop = m.fwInstance.getWidget("sourceTop")
            sourceTop.setFocus()

            ' When: Press right to enter targetGroup
            sourceTop.triggerKeyPress("right")

            ' Then: Focus should be on targetTop (both default and spatially closest)
            focusedWidget = m.fwInstance.plugins.focus.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "targetTop")
        end function

        @it("without enableSpatialEnter uses defaultFocusId regardless of position")
        function _()
            ' Given: targetGroup does NOT have enableSpatialEnter
            ' Focus is on sourceBottom (y=200), targetTop is defaultFocusId at y=0
            template = {
                id: "noSpatialEnterRoot",
                nodeType: "Group",
                focusGroup: {
                    defaultFocusId: "sourceGroup"
                },
                children: [
                    {
                        id: "sourceGroup",
                        nodeType: "Group",
                        fields: { translation: [0, 0] },
                        focusGroup: {
                            defaultFocusId: "sourceTop",
                            right: "targetGroup"
                        },
                        children: [
                            {
                                id: "sourceTop",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 0] },
                                focus: {}
                            },
                            {
                                id: "sourceBottom",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 200] },
                                focus: {}
                            }
                        ]
                    },
                    {
                        id: "targetGroup",
                        nodeType: "Group",
                        fields: { translation: [300, 0] },
                        focusGroup: {
                            defaultFocusId: "targetTop",
                            left: "sourceGroup"
                        },
                        children: [
                            {
                                id: "targetTop",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 0] },
                                focus: {}
                            },
                            {
                                id: "targetBottom",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 200] },
                                focus: {}
                            }
                        ]
                    }
                ]
            }

            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            ' Focus sourceBottom
            sourceBottom = m.fwInstance.getWidget("sourceBottom")
            sourceBottom.setFocus()

            ' When: Press right to enter targetGroup
            sourceBottom.triggerKeyPress("right")

            ' Then: Focus should be on targetTop (defaultFocusId), NOT spatially closest
            focusedWidget = m.fwInstance.plugins.focus.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "targetTop")
        end function

        @it("works even when source focusItem has enableSpatialNavigation=false")
        function _()
            ' Given: Source items have enableSpatialNavigation: false
            ' enableSpatialEnter uses its own distance calculation (not spatialNavigation())
            ' so it should still pick the closest item in the target group
            template = {
                id: "spatialEnterNoSpatialNavRoot",
                nodeType: "Group",
                focusGroup: {
                    defaultFocusId: "sourceGroup"
                },
                children: [
                    {
                        id: "sourceGroup",
                        nodeType: "Group",
                        fields: { translation: [0, 0] },
                        focusGroup: {
                            defaultFocusId: "sourceTop",
                            right: "targetGroup"
                        },
                        children: [
                            {
                                id: "sourceTop",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 0] },
                                focus: {
                                    enableSpatialNavigation: false
                                }
                            },
                            {
                                id: "sourceBottom",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 200] },
                                focus: {
                                    enableSpatialNavigation: false
                                }
                            }
                        ]
                    },
                    {
                        id: "targetGroup",
                        nodeType: "Group",
                        fields: { translation: [300, 0] },
                        focusGroup: {
                            defaultFocusId: "targetTop",
                            enableSpatialEnter: true,
                            left: "sourceGroup"
                        },
                        children: [
                            {
                                id: "targetTop",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 0] },
                                focus: {}
                            },
                            {
                                id: "targetBottom",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 200] },
                                focus: {}
                            }
                        ]
                    }
                ]
            }

            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            ' Focus sourceBottom (which has enableSpatialNavigation: false)
            sourceBottom = m.fwInstance.getWidget("sourceBottom")
            sourceBottom.setFocus()

            ' When: Press right to enter targetGroup
            sourceBottom.triggerKeyPress("right")

            ' Then: enableSpatialEnter should still work - targetBottom is closest
            focusedWidget = m.fwInstance.plugins.focus.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "targetBottom")
        end function

        @it("falls back to defaultFocusId when no global focus is set")
        function _()
            ' Given: enableSpatialEnter group but no previous focus (edge case)
            template = {
                id: "spatialEnterFallbackRoot",
                nodeType: "Group",
                focusGroup: {
                    defaultFocusId: "targetGroup"
                },
                children: [
                    {
                        id: "targetGroup",
                        nodeType: "Group",
                        fields: { translation: [0, 0] },
                        focusGroup: {
                            defaultFocusId: "targetItem1",
                            enableSpatialEnter: true
                        },
                        children: [
                            {
                                id: "targetItem1",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 0] },
                                focus: {}
                            },
                            {
                                id: "targetItem2",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 200] },
                                focus: {}
                            }
                        ]
                    }
                ]
            }

            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            ' When: Set focus on group (no prior focus exists)
            targetGroup = m.fwInstance.getWidget("targetGroup")
            targetGroup.setFocus()

            ' Then: Should fall back to defaultFocusId since no previous focus for spatial calc
            focusedWidget = m.fwInstance.plugins.focus.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "targetItem1")
        end function

        @it("enableSpatialEnter skips lastFocusedHID and uses spatial calculation")
        function _()
            ' Given: enableSpatialEnter group where lastFocusedHID was set to targetTop
            ' but current focus position is closer to targetBottom
            template = {
                id: "spatialEnterSkipLastRoot",
                nodeType: "Group",
                focusGroup: {
                    defaultFocusId: "sourceGroup"
                },
                children: [
                    {
                        id: "sourceGroup",
                        nodeType: "Group",
                        fields: { translation: [0, 0] },
                        focusGroup: {
                            defaultFocusId: "sourceTop",
                            right: "targetGroup"
                        },
                        children: [
                            {
                                id: "sourceTop",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 0] },
                                focus: {}
                            },
                            {
                                id: "sourceBottom",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 200] },
                                focus: {}
                            }
                        ]
                    },
                    {
                        id: "targetGroup",
                        nodeType: "Group",
                        fields: { translation: [300, 0] },
                        focusGroup: {
                            defaultFocusId: "targetTop",
                            enableSpatialEnter: true,
                            left: "sourceGroup"
                        },
                        children: [
                            {
                                id: "targetTop",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 0] },
                                focus: {}
                            },
                            {
                                id: "targetBottom",
                                nodeType: "Rectangle",
                                fields: { width: 100, height: 80, translation: [0, 200] },
                                focus: {}
                            }
                        ]
                    }
                ]
            }

            m.fwInstance.destroy()
            m.fwInstance = new Rotor.Framework()
            m.fwInstance.render(template)

            ' Step 1: Enter targetGroup from top (sets lastFocusedHID to targetTop)
            sourceTop = m.fwInstance.getWidget("sourceTop")
            sourceTop.setFocus()
            sourceTop.triggerKeyPress("right")

            ' Verify we're on targetTop
            focusedWidget = m.fwInstance.plugins.focus.getFocusedWidget()
            m.assertEqual(focusedWidget.id, "targetTop")

            ' Step 2: Navigate back to source
            targetTop = m.fwInstance.getWidget("targetTop")
            targetTop.triggerKeyPress("left")

            ' Step 3: Move to sourceBottom
            sourceBottom = m.fwInstance.getWidget("sourceBottom")
            sourceBottom.setFocus()

            ' Step 4: Re-enter targetGroup from bottom position
            sourceBottom.triggerKeyPress("right")

            ' Then: enableSpatialEnter should ignore lastFocusedHID (targetTop)
            '       and pick targetBottom (spatially closest)
            focusedWidget = m.fwInstance.plugins.focus.getFocusedWidget()
            m.assertNotInvalid(focusedWidget)
            m.assertEqual(focusedWidget.id, "targetBottom")
        end function

        @it("enableSpatialEnter defaults to false on groups")
        function _()
            ' Given: A group without enableSpatialEnter configured
            focusPlugin = m.fwInstance.plugins.focus
            groupL2Widget = m.fwInstance.getWidget("GroupL2")
            group = focusPlugin.groupStack.get(groupL2Widget.HID)

            ' Then: enableSpatialEnter should default to false
            m.assertFalse(group.enableSpatialEnter)
        end function

        @describe("focus plugin cleanup")

        @it("removeFocusConfig removes focus item from stack")
        function _()
            ' Given: L1 widget with focus config
            l1Widget = m.fwInstance.getWidget("L1")
            focusPlugin = m.fwInstance.plugins.focus

            ' Verify L1 is in focus stack
            focusItem = focusPlugin.focusItemStack.get(l1Widget.HID)
            m.assertNotInvalid(focusItem)

            ' When: Remove focus config
            focusPlugin.removeFocusConfig(l1Widget.HID)

            ' Then: L1 should be removed from stack
            focusItem = focusPlugin.focusItemStack.get(l1Widget.HID)
            m.assertInvalid(focusItem)
        end function

        @it("destroy cleans up focus plugin resources")
        function _()
            ' Given: Focus plugin with active focus
            focusPlugin = m.fwInstance.plugins.focus
            l1Widget = m.fwInstance.getWidget("L1")
            m.assertNotInvalid(l1Widget)

            ' Verify L1 is in focus stacks before destroy
            focusItem = focusPlugin.focusItemStack.get(l1Widget.HID)
            m.assertNotInvalid(focusItem)

            ' When: Destroy plugin
            focusPlugin.destroy()

            ' Then: Focus stacks should be empty
            m.assertEqual(focusPlugin.focusItemStack.getAll().Count(), 0)
            m.assertEqual(focusPlugin.groupStack.getAll().Count(), 0)

            ' Timer should be invalid
            m.assertInvalid(focusPlugin.longPressTimer)
            m.assertInvalid(focusPlugin.widgetTree)
        end function

        end class
end namespace
