import "pkg:/source/rotor/RotorFramework.bs"
import "pkg:/components/tests/dispatcherTest/dispatcherTest.const.bs"
import "pkg:/components/tests/dispatcherTest/dispatcherTest.template.bs"
import "pkg:/components/tests/dispatcherTest/dispatcherTest.dispatcher.bs"

namespace tests

    ' ******************************************************************
    ' ** Note:
    ' **
    ' ** The main difference between the "DispatcherTest" and the "DispatcherCrossThreadTest"
    ' ** is that the cross-thread Dispatcher runs inside a task thread, demonstrating that
    ' ** the same dispatcher pattern can be used there and available in render thread as well.
    ' ** With this approach, the entire application state management can be implemented -
    ' ** using MVI design patter. It allows building a fetch pool, maintaining a single source of truth, etc.
    ' **
    ' ** It’s important to note that when a Dispatcher is created in the render thread,
    ' ** it can only be used for purposes that exist within that render context —
    ' ** for example, as a controller or logic layer for a specific UI component.
    ' ******************************************************************

    @SGNode("dispatcherTest")
    @suite("dispatcherCrossThreadTest integration")
    class dispatcherCrossThreadTest extends rooibos.BaseTestSuite

        fwInstance as Rotor.Framework

        protected override function setup()
            m.fwInstance = new Rotor.Framework({
                tasks: ["DispatcherCrossThreadTest"],
                readyFieldId: "isReady"
            })
        end function

        protected override function beforeEach()
        end function

        protected override function afterEach()
        end function

        @describe("task-thread dispatcher delivers state to render thread")

        @async()
        @it("awaits task-ready signal before assertions")
        function _()
            m.waitForReady()
        end function

        private sub waitForReady()
            rootNode = m.fwInstance.getRootNode()
            if rootNode?.isReady = true
                template = getDispatcherTestTemplate()
                m.fwInstance.render(template)
                m.done()
            else
                rooibos_promises_internal_delay(function(ctx as dynamic)
                    ctx.waitForReady()
                end function, m, 0.0005)
            end if
        end sub

        @async()
        @it("reports initial cross-thread dispatcher state")
        function _()
            rootNode = m.fwInstance.getRootNode()
            rootWidget = m.fwInstance.getRootWidget()
            ancestorWidget = m.fwInstance.getWidget("ancestorViewModel")
            descendantWidget = m.fwInstance.getWidget("descendantViewModel")
            m.assertNotEqual(rootWidget, invalid)
            m.assertNotEqual(ancestorWidget, invalid)
            m.assertNotEqual(descendantWidget, invalid)

            fooDispatcher = m.fwInstance.getDispatcher("fooDispatcher")
            fooDispatcherState = fooDispatcher.getState()
            m.assertEqual(fooDispatcherState.hitCounter, 0)
            m.assertEqual(fooDispatcherState.foo, "bar")

            m.done()
        end function

        @async()
        @it("propagates child dispatch to ancestor view")
        function _()
            fooDispatcher = m.fwInstance.getDispatcher("fooDispatcher")
            ancestorWidget = m.fwInstance.getWidget("ancestorViewModel")
            descendantWidget = m.fwInstance.getWidget("descendantViewModel")

            m.assertEqual(ancestorWidget.props.foo, "bar")

            ' Start async test: validate dispatchUpdateFoo
            descendantWidget.dispatchUpdateFoo("baz") ' Runs async since this is a cross-thread dispatch
            rooibos_promises_internal_delay(function(ctx as dynamic)
                ancestorWidget = ctx.fwInstance.getWidget("ancestorViewModel")
                ctx.assertEqual(ancestorWidget.props.foo, "baz")

                fooDispatcher = ctx.fwInstance.getDispatcher("fooDispatcher")
                hitCounter = fooDispatcher.getState().hitCounter
                ctx.assertEqual(hitCounter, 1)

                ctx.done()
            end function, m, 0.09)

        end function

        @async()
        @it("ignores BLOCK_BY_MIDDLEWARE intents")
        function _()
            fooDispatcher = m.fwInstance.getDispatcher("fooDispatcher")
            fooDispatcher.dispatch({
                type: IntentTypes.BLOCK_BY_MIDDLEWARE,
                payload: {
                    foo: invalid
                }
            })
            ' Start async test: validate BLOCK_BY_MIDDLEWARE
            rooibos_promises_internal_delay(function(ctx as dynamic)
                fooDispatcher = ctx.fwInstance.getDispatcher("fooDispatcher")
                hitCounter = fooDispatcher.getState().hitCounter
                ctx.assertEqual(hitCounter, 1, "state.hitCounter should not change when IntentTypes.BLOCK_BY_MIDDLEWARE")

                ctx.destroyFw()
                ctx.done()
            end function, m, 0.09)
        end function

        sub destroyFw()
            m.fwInstance.destroy()
            m.fwInstance = invalid
        end sub

    end class
end namespace
