import "pkg:/source/RotorFramework.bs"
import "pkg:/components/tests/viewModelTest/ViewModelTest.template.bs"
import "pkg:/components/tests/viewModelTest/ViewModelTest.const.bs"

namespace tests

    @SGNode("viewModelTest")
    @suite("ViewModelTestSuite integration")
    class ViewModelTestSuite extends rooibos.BaseTestSuite

        fwInstance as Rotor.Framework

        protected override function beforeEach()
            ' Initialize framework
            m.fwInstance = new Rotor.Framework()
            ' Render
            template = getViewModelTemplate()
            m.fwInstance.render(template)
        end function

        protected override function afterEach()
            m.fwInstance.destroy()
            m.fwInstance = invalid
        end function

        @describe("view model rendering")

        @it("renders view model template with updated props")
        function _()
            viewModelTest = m.fwInstance.getRootWidget().children.viewModelTest
            m.assertNotEqual(viewModelTest, invalid)

            titleNode = m.fwInstance.getWidget("titleLabel").node
            subtitleNode = m.fwInstance.getWidget("subtitleLabel").node
            m.assertNotEqual(titleNode, invalid)
            m.assertNotEqual(subtitleNode, invalid)

            titleNodeText = `${VIEW_MODEL_DEFAULT_PROPS.title} created mounted`
            m.assertEqual(titleNode.text, titleNodeText)
            subtitleNodeText = `${VIEW_MODEL_DEFAULT_PROPS.subtitle} created mounted`
            m.assertEqual(subtitleNode.text, subtitleNodeText)

            ' Update ViewModel with new props (rendering runs synchronously)
            viewModelTest.render({
                props: {
                    title: `${titleNodeText} updated`,
                    subtitle: `${subtitleNodeText} updated`,
                }
            })
            ' Check viewModelState.updateCount value
            ' * One Render was called on Mounted - see template
            ' * Another Render was called in this test
            m.assertEqual(viewModelTest.viewModelState.updateCount, 2)

            ' Validate new texts
            m.assertEqual(titleNode.text, `${titleNodeText} updated`)
            m.assertEqual(subtitleNode.text, `${subtitleNodeText} updated`)

            ' Assert that hint text was populated from viewModelState.foo through the Fields Plugin
            ' ViewModelState properties are accessible through the Fields Plugin using the "@" operator
            hintLabelNode = m.fwInstance.getWidget("hintLabel").node
            m.assertEqual(hintLabelNode.text, viewModelTest.viewModelState.foo)

        end function

        @describe("widget update lifecycle callbacks")

        @it("onUpdateWidget callback is triggered when widget is updated")
        function _()
            ' Given: A widget with onUpdateWidget callback
            updateCallbackFired = false

            m.fwInstance.render({
                id: "testWidget",
                nodeType: "Group",
                onUpdateWidget: sub()
                    m.updateCallbackFired = true
                end sub
            })

            widget = m.fwInstance.getWidget("testWidget")
            m.assertNotInvalid(widget)

            ' When: Update the widget
            widget.render({
                onUpdateWidget: sub()
                    m.updateCallbackFired = true
                end sub,
                viewModelState: {
                    testValue: "updated"
                }
            })

            ' Then: onUpdateWidget should be set
            m.assertNotInvalid(widget.onUpdateWidget)
        end function

        @it("onDestroyWidget callback is set during update")
        function _()
            ' Given: A widget
            m.fwInstance.render({
                id: "testWidget2",
                nodeType: "Group"
            })

            widget = m.fwInstance.getWidget("testWidget2")
            m.assertNotInvalid(widget)
            m.assertInvalid(widget.onDestroyWidget)

            ' When: Update with onDestroyWidget callback
            widget.render({
                onDestroyWidget: sub()
                    ' Cleanup logic here
                end sub
            })

            ' Then: onDestroyWidget should be set
            m.assertNotInvalid(widget.onDestroyWidget)
        end function

        @it("onRenderSettled callback is processed during update")
        function _()
            ' Given: Existing widget
            m.fwInstance.render({
                id: "testWidget3",
                nodeType: "Group"
            })

            widget = m.fwInstance.getWidget("testWidget3")
            m.assertNotInvalid(widget)

            ' When: Update widget with onRenderSettled and viewModelState change
            ' (onRenderSettled gets queued and processed immediately by render)
            callbackExecuted = false
            widget.render({
                viewModelState: {
                    test: "value"
                },
                onRenderSettled: sub()
                    m.callbackExecuted = true
                end sub
            })

            ' Then: Widget should be updated (onRenderSettled was processed)
            ' The callback is executed synchronously during render
            m.assertNotInvalid(widget.viewModelState)
            m.assertEqual(widget.viewModelState.test, "value")
        end function

        @it("zIndex update triggers reindexing")
        function _()
            ' Given: Parent with children
            m.fwInstance.render({
                id: "parentWidget",
                nodeType: "Group",
                children: [
                    {
                        id: "child1",
                        nodeType: "Rectangle",
                        fields: { color: "0xFF0000FF" }
                    },
                    {
                        id: "child2",
                        nodeType: "Rectangle",
                        fields: { color: "0x00FF00FF" }
                    }
                ]
            })

            child1 = m.fwInstance.getWidget("child1")
            child2 = m.fwInstance.getWidget("child2")

            m.assertNotInvalid(child1)
            m.assertNotInvalid(child2)

            ' When: Update child2 with new zIndex
            child2.render({
                zIndex: 0  ' Move to front
            })

            ' Then: Child should exist (zIndex reordering happens in post-process)
            m.assertNotInvalid(m.fwInstance.getWidget("child2"))
        end function

        @it("viewModelState update merges new values")
        function _()
            ' Given: ViewModel with initial viewModelState
            viewModelTest = m.fwInstance.getWidget("viewModelTest")
            m.assertNotInvalid(viewModelTest)
            m.assertNotInvalid(viewModelTest.viewModelState)

            ' Set initial values
            viewModelTest.viewModelState.value1 = "initial"
            viewModelTest.viewModelState.value2 = 100

            ' When: Update with new viewModelState values
            viewModelTest.render({
                viewModelState: {
                    value1: "updated",
                    value3: "new"
                }
            })

            ' Then: Values should be merged (deepExtendAA preserves existing keys)
            m.assertEqual(viewModelTest.viewModelState.value1, "updated")
            m.assertEqual(viewModelTest.viewModelState.value2, 100)  ' Preserved
            m.assertEqual(viewModelTest.viewModelState.value3, "new")  ' Added
        end function

        @it("widget update with plugin triggers beforeUpdate and afterUpdated hooks")
        function _()
            ' Given: Widget with fields (fields plugin)
            m.fwInstance.render({
                id: "pluginWidget",
                nodeType: "Label",
                fields: {
                    text: "Original Text"
                }
            })

            widget = m.fwInstance.getWidget("pluginWidget")
            node = widget.node
            m.assertEqual(node.text, "Original Text")

            ' When: Update fields
            widget.render({
                fields: {
                    text: "Updated Text"
                }
            })

            ' Then: Fields should be updated (plugin processed the update)
            m.assertEqual(node.text, "Updated Text")
        end function

        @describe("framework lifecycle")

        @it("framework destroy cleans up all resources")
        function _()
            ' Given: Create new framework instance (independent of beforeEach)
            frameworkInstance = new Rotor.Framework()

            ' When: Render template
            template = getViewModelTemplate()
            frameworkInstance.render(template)

            ' Verify framework is initialized
            m.assertNotInvalid(frameworkInstance)
            m.assertNotInvalid(frameworkInstance.builder)
            rootWidget = frameworkInstance.getRootWidget()
            m.assertNotInvalid(rootWidget)

            ' Get reference to widget before destroy
            viewModelWidget = frameworkInstance.getWidget("viewModelTest")
            m.assertNotInvalid(viewModelWidget)

            ' When: Destroy framework
            frameworkInstance.destroy()

            ' Then: Framework resources should be cleaned up
            ' Builder's widget tree should be cleared
            m.assertInvalid(frameworkInstance.builder.widgetTree.root)

            ' Widgets should be removed from tree
            widgetAfterDestroy = frameworkInstance.getWidget("viewModelTest")
            m.assertInvalid(widgetAfterDestroy)
        end function

        end class
    end namespace
