import "pkg:/source/RotorFramework.bs"
import "pkg:/components/tests/ttsTest/TtsTest.template.bs"

namespace tests

    @SGNode("ttsTest")
    @suite("TtsTest integration")
    class TtsTestSuite extends rooibos.BaseTestSuite

        fwInstance as Rotor.Framework

        protected override function beforeEach()
            ' Initialize framework
            m.fwInstance = new Rotor.Framework()
            ' Render
            template = getTtsTestTemplate()
            m.fwInstance.render(template)
        end function

        protected override function afterEach()
            m.fwInstance.destroy()
            m.fwInstance = invalid
        end function

        @describe("TTS service integration")

        @it("widget has access to tts service via decorator")
        function _()
            ttsTestWidget = m.fwInstance.getRootWidget().children.ttsTest
            m.assertNotInvalid(ttsTestWidget)

            ' Test that tts() returns the service
            ttsService = ttsTestWidget.tts()
            m.assertNotInvalid(ttsService)

            ' Service should have speak method
            m.assertNotInvalid(ttsService.speak)
        end function

        @it("tts service has stopSpeech method")
        function _()
            widget = m.fwInstance.getWidget("ttsTest")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            m.assertNotInvalid(ttsService.stopSpeech)
        end function

        @it("tts service has setSymbolDictionary method")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            m.assertNotInvalid(ttsService.setSymbolDictionary)
        end function

        @it("tts service has enable and disable methods")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            m.assertNotInvalid(ttsService.enable)
            m.assertNotInvalid(ttsService.disable)
        end function

        @describe("speak method integration")

        @it("speak method is callable via widget decorator")
        function _()
            widget = m.fwInstance.getWidget("ttsTest")
            m.assertNotInvalid(widget)

            ' TTS service should be accessible
            ttsService = widget.tts()
            m.assertNotInvalid(ttsService)

            ' Service has isEnabled flag (value depends on device support)
            m.assertNotInvalid(ttsService.isEnabled)
        end function

        @it("speak method accepts config with say parameter")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ' Should not crash even if disabled
            ttsService = widget.tts()
            ttsService.speak({
                say: "Test message"
            })

            ' Test passes if no crash occurs
            m.assertTrue(true)
        end function

        @it("speak method accepts flush parameter")
        function _()
            widget = m.fwInstance.getWidget("ttsTest")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            ttsService.speak({
                say: "Test with flush",
                flush: true
            })

            ' Test passes if no crash occurs
            m.assertTrue(true)
        end function

        @it("speak method accepts spellOut parameter")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            ttsService.speak({
                say: "ABC",
                spellOut: true
            })

            ' Test passes if no crash occurs
            m.assertTrue(true)
        end function

        @describe("processSpellOutMode public method")

        @it("processSpellOutMode splits regular text with spaces")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            result = ttsService.processSpellOutMode("ABC")

            m.assertEqual(result, "A B C")
        end function

        @it("processSpellOutMode handles email addresses")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            result = ttsService.processSpellOutMode("user@domain.com")

            m.assertEqual(result, "user at domain dot com")
        end function

        @it("processSpellOutMode handles decimal numbers")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            result = ttsService.processSpellOutMode("3.14")

            m.assertEqual(result, "3 point 14")
        end function

        @it("processSpellOutMode replaces symbols with words")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            result = ttsService.processSpellOutMode("@#$")

            m.assertEqual(result, "at hash dollar")
        end function

        @it("processSpellOutMode handles empty string")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            result = ttsService.processSpellOutMode("")

            m.assertEqual(result, "")
        end function

        @it("processSpellOutMode handles mixed alphanumeric text")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            result = ttsService.processSpellOutMode("A1B2")

            m.assertEqual(result, "A 1 B 2")
        end function

        @describe("symbol dictionary customization")

        @it("setSymbolDictionary updates dictionary and affects spellOut")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Set Hungarian localization
            ttsService.setSymbolDictionary({
                "@": "kukac",
                ".": "pont"
            })

            result = ttsService.processSpellOutMode("@.")

            m.assertEqual(result, "kukac pont")
        end function

        @describe("service state management")

        @it("enable method sets isEnabled to true")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            initialState = ttsService.isEnabled

            ' Enable service
            ttsService.enable()

            ' Should be enabled (if device supports AudioGuide)
            ' In test environment this depends on device
            m.assertNotInvalid(ttsService.isEnabled)
        end function

        @it("disable method sets isEnabled to false")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Disable service
            ttsService.disable()

            ' Should be disabled
            m.assertFalse(ttsService.isEnabled)
        end function

        @it("enable sets TTS service to enabled state")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Disable first
            ttsService.disable()
            m.assertFalse(ttsService.isEnabled)

            ' Enable
            ttsService.enable()
            m.assertTrue(ttsService.isEnabled)
        end function

        @it("disable sets TTS service to disabled state")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Enable first
            ttsService.enable()
            m.assertTrue(ttsService.isEnabled)

            ' Disable
            ttsService.disable()
            m.assertFalse(ttsService.isEnabled)
        end function

        @it("stopSpeech clears pending speech and override flag")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Call stopSpeech
            ttsService.stopSpeech()

            ' Verify flags are cleared
            m.assertInvalid(ttsService.pendingSpeech)
            m.assertFalse(ttsService.preventNextFlushFlag)
        end function

        @describe("edge cases")

        @it("processSpellOutMode handles special characters and spaces")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            result = ttsService.processSpellOutMode("test_file-name.txt")

            ' Should spell out with symbol replacements
            m.assertTrue(Len(result) > 10)
            m.assertTrue(result.Instr("underscore") > 0)
            m.assertTrue(result.Instr("dash") > 0)
            m.assertTrue(result.Instr("dot") > 0)
        end function

        @it("speak handles empty say parameter gracefully")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Should not crash with empty string
            ttsService.speak({
                say: ""
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("speak handles invalid config gracefully")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Should not crash with invalid say
            ttsService.speak({})

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @describe("dontRepeat functionality")

        @it("dontRepeat skips duplicate speech")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' First call - should set lastSpeech
            ttsService.speak({
                say: "Test message",
                dontRepeat: true
            })

            ' Store lastSpeech value
            firstLastSpeech = ttsService.lastSpeech

            ' Second call with same text and dontRepeat
            ttsService.speak({
                say: "Test message",
                dontRepeat: true
            })

            ' lastSpeech should remain the same (duplicate was skipped)
            m.assertEqual(ttsService.lastSpeech, firstLastSpeech)
        end function

        @it("dontRepeat false allows duplicate speech")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Call without dontRepeat - should not skip
            ttsService.speak({
                say: "Test message",
                dontRepeat: false
            })

            ' Second call should also execute (no skip)
            ttsService.speak({
                say: "Test message",
                dontRepeat: false
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @describe("preventNextFlush functionality")

        @it("preventNextFlush protects speech from being flushed")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Speak with override protection
            ttsService.speak({
                say: "Protected message",
                preventNextFlush: true,
                flush: true
            })

            ' Flag should be set
            m.assertTrue(ttsService.preventNextFlushFlag)

            ' Next flush should clear the flag
            ttsService.speak({
                say: "New message",
                flush: true
            })

            ' Flag should now be cleared
            m.assertFalse(ttsService.preventNextFlushFlag)
        end function

        @it("preventNextFlush false does not set protection")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Speak without override protection
            ttsService.speak({
                say: "Unprotected message",
                preventNextFlush: false,
                flush: true
            })

            ' Flag should remain false
            m.assertFalse(ttsService.preventNextFlushFlag)
        end function

        @describe("combination tests")

        @it("speak with flush and spellOut combination")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Should not crash with combined options
            ttsService.speak({
                say: "ABC123",
                flush: true,
                spellOut: true
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("speak with flush and dontRepeat combination")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' First call with flush and dontRepeat
            ttsService.speak({
                say: "Combined test",
                flush: true,
                dontRepeat: true
            })

            ' Second call should be skipped by dontRepeat
            ttsService.speak({
                say: "Combined test",
                flush: true,
                dontRepeat: true
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("speak with all options enabled")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Should handle all options together
            ttsService.speak({
                say: "Full test",
                flush: true,
                spellOut: true,
                preventNextFlush: true,
                dontRepeat: true
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @describe("pending speech management")

        @it("speak without flush stores speech as pending")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Speak without flush - should be pending
            ttsService.speak({
                say: "Pending message"
            })

            ' If enabled, pendingSpeech should be set
            ' If disabled, pendingSpeech remains invalid
            ' Just verify the service handled it
            m.assertNotInvalid(ttsService)
        end function

        @it("speak with flush clears pending speech")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' First speak without flush to set pending
            ttsService.speak({
                say: "Pending message"
            })

            ' Then flush - should clear pending
            ttsService.speak({
                say: "Flush message",
                flush: true
            })

            ' Pending should be cleared by flush
            ' (if service was enabled and executed)
            m.assertNotInvalid(ttsService)
        end function

        @describe("lastSpeech tracking")

        @it("lastSpeech is updated after speaking")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            initialLastSpeech = ttsService.lastSpeech

            ' Speak to update lastSpeech
            ttsService.speak({
                say: "Track this",
                flush: true
            })

            ' If service is enabled, lastSpeech might be updated
            ' If disabled, it remains unchanged
            ' Just verify service exists
            m.assertNotInvalid(ttsService.lastSpeech)
        end function

        @it("lastSpeech can be empty initially")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Initial lastSpeech should be empty string
            m.assertEqual(ttsService.lastSpeech, "")
        end function

        @describe("onceKey functionality")

        @it("onceKey parameter caches speech and skips on repeat")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' First call with onceKey - should speak and cache
            ttsService.speak({
                say: "Welcome message",
                onceKey: "welcome-test"
            })

            ' Verify key is cached
            m.assertTrue(ttsService.skipCache.DoesExist("welcome-test"))

            ' Second call with same onceKey - should skip
            ttsService.speak({
                say: "Welcome message",
                onceKey: "welcome-test"
            })

            ' Key should still be cached
            m.assertTrue(ttsService.skipCache.DoesExist("welcome-test"))
        end function

        @it("onceKey with different key allows speech")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' First call
            ttsService.speak({
                say: "First message",
                onceKey: "key1"
            })

            ' Second call with different key
            ttsService.speak({
                say: "Second message",
                onceKey: "key2"
            })

            ' Both keys should be cached
            m.assertTrue(ttsService.skipCache.DoesExist("key1"))
            m.assertTrue(ttsService.skipCache.DoesExist("key2"))
        end function

        @it("onceKey with same key but different text still skips")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' First call
            ttsService.speak({
                say: "English text",
                onceKey: "welcome-message"
            })

            ' Second call - different text, same key
            ttsService.speak({
                say: "French text",
                onceKey: "welcome-message"
            })

            ' Key should be cached (only once)
            m.assertTrue(ttsService.skipCache.DoesExist("welcome-message"))
        end function

        @it("onceKey invalid or missing does not cache")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Call without onceKey
            ttsService.speak({
                say: "No cache message"
            })

            ' Call with invalid onceKey
            ttsService.speak({
                say: "Invalid cache message",
                onceKey: invalid
            })

            ' skipCache should be empty or not have invalid entries
            m.assertNotInvalid(ttsService.skipCache)
        end function

        @it("removeOnceKey removes key from cache")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Add key to cache
            ttsService.speak({
                say: "Cached message",
                onceKey: "removable-key"
            })

            ' Verify cached
            m.assertTrue(ttsService.skipCache.DoesExist("removable-key"))

            ' Remove key
            ttsService.removeOnceKey("removable-key")

            ' Verify removed
            m.assertFalse(ttsService.skipCache.DoesExist("removable-key"))
        end function

        @it("removeOnceKey on non-existent key does not crash")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Remove non-existent key
            ttsService.removeOnceKey("non-existent-key")

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("after removeOnceKey, same key can speak again")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' First call
            ttsService.speak({
                say: "First time",
                onceKey: "repeat-test"
            })

            ' Verify cached
            m.assertTrue(ttsService.skipCache.DoesExist("repeat-test"))

            ' Remove key
            ttsService.removeOnceKey("repeat-test")

            ' Key should be removed
            m.assertFalse(ttsService.skipCache.DoesExist("repeat-test"))

            ' Second call with same key should cache again
            ttsService.speak({
                say: "Second time",
                onceKey: "repeat-test"
            })

            ' Should be cached again
            m.assertTrue(ttsService.skipCache.DoesExist("repeat-test"))
        end function

        @it("clearOnceCache clears all cached keys")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Add multiple keys
            ttsService.speak({
                say: "Message 1",
                onceKey: "key1"
            })
            ttsService.speak({
                say: "Message 2",
                onceKey: "key2"
            })
            ttsService.speak({
                say: "Message 3",
                onceKey: "key3"
            })

            ' Verify all cached
            m.assertTrue(ttsService.skipCache.DoesExist("key1"))
            m.assertTrue(ttsService.skipCache.DoesExist("key2"))
            m.assertTrue(ttsService.skipCache.DoesExist("key3"))

            ' Clear cache
            ttsService.clearOnceCache()

            ' Verify all removed
            m.assertFalse(ttsService.skipCache.DoesExist("key1"))
            m.assertFalse(ttsService.skipCache.DoesExist("key2"))
            m.assertFalse(ttsService.skipCache.DoesExist("key3"))
        end function

        @it("clearOnceCache on empty cache does not crash")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Clear empty cache
            ttsService.clearOnceCache()

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("onceKey works with flush combination")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' First call with onceKey and flush
            ttsService.speak({
                say: "Flush once message",
                onceKey: "flush-once",
                flush: true
            })

            ' Key should be cached
            m.assertTrue(ttsService.skipCache.DoesExist("flush-once"))

            ' Second call should skip
            ttsService.speak({
                say: "Flush once message",
                onceKey: "flush-once",
                flush: true
            })

            ' Still cached
            m.assertTrue(ttsService.skipCache.DoesExist("flush-once"))
        end function

        @it("onceKey works with all options combination")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Full combination
            ttsService.speak({
                say: "Full combo",
                onceKey: "combo-key",
                flush: true,
                spellOut: true,
                preventNextFlush: true,
                dontRepeat: true
            })

            ' Key should be cached
            m.assertTrue(ttsService.skipCache.DoesExist("combo-key"))
        end function

        @describe("processSayValue with function callback")

        @it("speak accepts function as say parameter")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Speak with function callback
            ttsService.speak({
                say: function()
                    return "Dynamic text from function"
                end function,
                flush: true
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("speak with function and context passes context to callback")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Speak with function and context
            ttsService.speak({
                say: function()
                    return "Value is " + m.testValue
                end function,
                context: { testValue: "42" },
                flush: true
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("speak with function returning non-string handles gracefully")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Function returns number instead of string
            ttsService.speak({
                say: function()
                    return 123
                end function,
                flush: true
            })

            ' Test passes if no crash (function returning non-string should be handled)
            m.assertTrue(true)
        end function

        @describe("context interpolation")

        @it("speak interpolates @ operator for viewModelState")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Speak with @ interpolation
            ttsService.speak({
                say: "Value is @testKey",
                context: {
                    viewModelState: { testKey: "interpolated" }
                },
                flush: true
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("speak interpolates $ operator for context properties")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Speak with $ interpolation
            ttsService.speak({
                say: "Count is $count",
                context: { count: "5" },
                flush: true
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("speak handles multiple interpolations in same string")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Multiple interpolations
            ttsService.speak({
                say: "User @name has $count items",
                context: {
                    viewModelState: { name: "John" },
                    count: "3"
                },
                flush: true
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("speak handles unknown interpolation operators gracefully")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Unknown operator should be skipped
            ttsService.speak({
                say: "Value is @unknownKey",
                context: {}, ' No viewModelState
                flush: true
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @describe("isPendingProtected flag behavior")

        @it("isPendingProtected is set when preventNextFlush triggers protection")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Initial state
            m.assertFalse(ttsService.isPendingProtected)

            ' First call with preventNextFlush
            ttsService.speak({
                say: "Protected speech",
                preventNextFlush: true,
                flush: true
            })

            ' Flag should be set for protection
            m.assertTrue(ttsService.preventNextFlushFlag)

            ' Second call triggers protection transfer to isPendingProtected
            ttsService.speak({
                say: "Next speech",
                flush: true
            })

            ' Protection should transfer
            m.assertTrue(ttsService.isPendingProtected)
        end function

        @it("isPendingProtected blocks flush on subsequent calls")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Set protection via preventNextFlush
            ttsService.speak({
                say: "Protected",
                preventNextFlush: true,
                flush: true
            })

            ' Next call should have flush blocked
            ttsService.speak({
                say: "Blocked flush",
                flush: true
            })

            ' Third call should also have flush blocked (isPendingProtected persists)
            ttsService.speak({
                say: "Also blocked",
                flush: true
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("stopSpeech clears isPendingProtected flag")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Set protection
            ttsService.speak({
                say: "Protected",
                preventNextFlush: true,
                flush: true
            })

            ttsService.speak({
                say: "Next",
                flush: true
            })

            ' isPendingProtected should be set
            m.assertTrue(ttsService.isPendingProtected)

            ' Stop speech
            ttsService.stopSpeech()

            ' isPendingProtected should be cleared
            m.assertFalse(ttsService.isPendingProtected)
        end function

        @describe("long and multi-sentence text handling")

        @it("long text over 50 chars forces flush")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Long text (over 50 chars) should force flush internally
            longText = "This is a very long text message that exceeds fifty characters for testing purposes"
            ttsService.speak({
                say: longText,
                flush: false ' Even with flush=false, long text forces flush internally
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("multi-sentence text forces flush")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Multi-sentence text should force flush
            ttsService.speak({
                say: "First sentence. Second sentence.",
                flush: false ' Even with flush=false, multi-sentence forces flush
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @describe("preventNextFlush with pending speech scenarios")

        @it("preventNextFlush executes pending speech first before new speech")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' First: set pending speech (no flush, goes to threshold)
            ttsService.speak({
                say: "Pending first"
            })

            ' Verify pending is set
            m.assertNotInvalid(ttsService.pendingSpeech)

            ' Then: call with preventNextFlush - should execute pending first
            ttsService.speak({
                say: "Override second",
                preventNextFlush: true,
                flush: true
            })

            ' Pending should be cleared (was executed)
            m.assertInvalid(ttsService.pendingSpeech)

            ' Protection flag should be set
            m.assertTrue(ttsService.preventNextFlushFlag)
        end function

        @it("preventNextFlush without pending executes immediately")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' No pending speech initially
            m.assertInvalid(ttsService.pendingSpeech)

            ' Call with preventNextFlush directly
            ttsService.speak({
                say: "Direct override",
                preventNextFlush: true,
                flush: true
            })

            ' Pending should still be invalid (no pending was created)
            m.assertInvalid(ttsService.pendingSpeech)

            ' Protection flag should be set
            m.assertTrue(ttsService.preventNextFlushFlag)
        end function

        @describe("timer and threshold behavior")

        @it("multiple rapid speaks replace pending speech")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' First speak - sets pending
            ttsService.speak({ say: "First" })
            firstPending = ttsService.pendingSpeech?.textToSpeak

            ' Second speak - replaces pending
            ttsService.speak({ say: "Second" })
            secondPending = ttsService.pendingSpeech?.textToSpeak

            ' Third speak - replaces pending again
            ttsService.speak({ say: "Third" })
            thirdPending = ttsService.pendingSpeech?.textToSpeak

            ' Final pending should be "Third" (spellOut processed)
            m.assertNotInvalid(ttsService.pendingSpeech)
            m.assertEqual(ttsService.pendingSpeech.textToSpeak, "Third")
        end function

        @it("timer node is stopped when preventNextFlush clears pending")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Set pending speech
            ttsService.speak({ say: "Pending" })

            ' Timer should be started
            m.assertNotInvalid(ttsService.timerNode)

            ' preventNextFlush clears pending and stops timer
            ttsService.speak({
                say: "Override",
                preventNextFlush: true
            })

            ' Pending should be cleared
            m.assertInvalid(ttsService.pendingSpeech)
        end function

        @describe("speakSingle protection handling")

        @it("speakSingle blocks flush when preventNextFlushFlag is set")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Set protection flag directly
            ttsService.preventNextFlushFlag = true

            ' Speak with flush - should be blocked
            ttsService.speak({
                say: "Blocked flush speech",
                flush: true
            })

            ' Flag should be cleared after use
            ' (it gets cleared either by preventNextFlush logic or speakSingle)
            ' Test passes if no crash
            m.assertTrue(true)
        end function

        ' ======================================================================
        ' TEST SUITE: onDebounceTimer direct call
        ' ======================================================================

        @describe("onDebounceTimer direct call")

        @it("onDebounceTimer executes pending speech and clears it")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            ttsService.enable()

            ' Queue pending speech (no flush goes to threshold)
            ttsService.speak({ say: "Pending debounce test" })

            ' Verify pending is set
            m.assertNotInvalid(ttsService.pendingSpeech)
            m.assertEqual(ttsService.pendingSpeech.textToSpeak, "Pending debounce test")

            ' When: Call onDebounceTimer directly (simulates timer firing)
            ttsService.onDebounceTimer()

            ' Then: pendingSpeech should be cleared
            m.assertInvalid(ttsService.pendingSpeech)

            ' isPendingProtected should be cleared
            m.assertFalse(ttsService.isPendingProtected)
        end function

        @it("onDebounceTimer returns early when no pending speech")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            ttsService.enable()

            ' Ensure no pending speech
            m.assertInvalid(ttsService.pendingSpeech)

            ' When: Call onDebounceTimer with no pending
            ttsService.onDebounceTimer()

            ' Then: Should not crash (early return)
            m.assertInvalid(ttsService.pendingSpeech)
        end function

        ' ======================================================================
        ' TEST SUITE: dontRepeat with enabled TTS
        ' ======================================================================

        @describe("dontRepeat with enabled TTS")

        @it("dontRepeat skips duplicate speech when TTS is enabled")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            ttsService.enable()

            ' First call with flush and dontRepeat
            ttsService.speak({
                say: "Hello enabled",
                dontRepeat: true,
                flush: true
            })

            ' Let the debounce timer fire to set lastSpeech
            ttsService.onDebounceTimer()

            firstLastSpeech = ttsService.lastSpeech
            m.assertEqual(firstLastSpeech, "Hello enabled")

            ' Second call with same text and dontRepeat - should be skipped
            ttsService.speak({
                say: "Hello enabled",
                dontRepeat: true,
                flush: true
            })

            ' lastSpeech should remain the same (duplicate was skipped at line 198-202)
            m.assertEqual(ttsService.lastSpeech, firstLastSpeech)
        end function

        ' ======================================================================
        ' TEST SUITE: Invalid say type handling
        ' ======================================================================

        @describe("invalid say type handling")

        @it("speak with numeric say value does not crash")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            ttsService.enable()

            ' Speak with numeric say value (not string, not function)
            ttsService.speak({
                say: 123
            })

            ' Should not crash - processSayValue returns "" for non-string/non-function
            m.assertTrue(true)
        end function

        @it("speak with boolean say value does not crash")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            ttsService.enable()

            ' Speak with boolean say value
            ttsService.speak({
                say: true
            })

            ' Should not crash - processSayValue returns "" for non-string/non-function
            m.assertTrue(true)
        end function

        ' ======================================================================
        ' TEST SUITE: speakSingle flush protection with enabled TTS
        ' ======================================================================

        @describe("speakSingle flush protection with enabled TTS")

        @it("flush is blocked and flag cleared when preventNextFlushFlag is set with enabled TTS")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            ttsService.enable()

            ' Set protection flag directly
            ttsService.preventNextFlushFlag = true

            ' Speak with flush - flush should be blocked by protection
            ttsService.speak({
                say: "Protected flush test",
                flush: true
            })

            ' Let debounce timer fire to execute speech through speakSingle
            ttsService.onDebounceTimer()

            ' Flag should be cleared after use (line 369)
            m.assertFalse(ttsService.preventNextFlushFlag)

            ' lastSpeech should be set (speech was executed)
            m.assertEqual(ttsService.lastSpeech, "Protected flush test")
        end function

    end class
end namespace
