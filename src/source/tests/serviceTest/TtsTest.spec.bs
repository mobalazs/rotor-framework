import "pkg:/source/RotorFramework.bs"
import "pkg:/components/tests/ttsTest/TtsTest.template.bs"

namespace tests

    @SGNode("ttsTest")
    @suite("TtsTest integration")
    class TtsTestSuite extends rooibos.BaseTestSuite

        fwInstance as Rotor.Framework

        protected override function beforeEach()
            ' Initialize framework
            m.fwInstance = new Rotor.Framework()
            ' Render
            template = getTtsTestTemplate()
            m.fwInstance.render(template)
        end function

        protected override function afterEach()
            m.fwInstance.destroy()
            m.fwInstance = invalid
        end function

        @describe("TTS service integration")

        @it("widget has access to tts service via decorator")
        function _()
            ttsTestWidget = m.fwInstance.getRootWidget().children.ttsTest
            m.assertNotInvalid(ttsTestWidget)

            ' Test that tts() returns the service
            ttsService = ttsTestWidget.tts()
            m.assertNotInvalid(ttsService)

            ' Service should have speak method
            m.assertNotInvalid(ttsService.speak)
        end function

        @it("tts service has stopSpeech method")
        function _()
            widget = m.fwInstance.getWidget("ttsTest")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            m.assertNotInvalid(ttsService.stopSpeech)
        end function

        @it("tts service has setSymbolDictionary method")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            m.assertNotInvalid(ttsService.setSymbolDictionary)
        end function

        @it("tts service has toggleAudioGuide method")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            m.assertNotInvalid(ttsService.toggleAudioGuide)
        end function

        @describe("speak method integration")

        @it("speak method is callable via widget decorator")
        function _()
            widget = m.fwInstance.getWidget("ttsTest")
            m.assertNotInvalid(widget)

            ' TTS service should be accessible
            ttsService = widget.tts()
            m.assertNotInvalid(ttsService)

            ' Service has isEnabled flag (value depends on device support)
            m.assertNotInvalid(ttsService.isEnabled)
        end function

        @it("speak method accepts config with say parameter")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ' Should not crash even if disabled
            ttsService = widget.tts()
            ttsService.speak({
                say: "Test message"
            })

            ' Test passes if no crash occurs
            m.assertTrue(true)
        end function

        @it("speak method accepts flush parameter")
        function _()
            widget = m.fwInstance.getWidget("ttsTest")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            ttsService.speak({
                say: "Test with flush",
                flush: true
            })

            ' Test passes if no crash occurs
            m.assertTrue(true)
        end function

        @it("speak method accepts spellOut parameter")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            ttsService.speak({
                say: "ABC",
                spellOut: true
            })

            ' Test passes if no crash occurs
            m.assertTrue(true)
        end function

        @describe("processSpellOutMode public method")

        @it("processSpellOutMode splits regular text with spaces")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            result = ttsService.processSpellOutMode("ABC")

            m.assertEqual(result, "A B C")
        end function

        @it("processSpellOutMode handles email addresses")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            result = ttsService.processSpellOutMode("user@domain.com")

            m.assertEqual(result, "user at domain dot com")
        end function

        @it("processSpellOutMode handles decimal numbers")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            result = ttsService.processSpellOutMode("3.14")

            m.assertEqual(result, "3 point 14")
        end function

        @it("processSpellOutMode replaces symbols with words")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            result = ttsService.processSpellOutMode("@#$")

            m.assertEqual(result, "at hash dollar")
        end function

        @it("processSpellOutMode handles empty string")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            result = ttsService.processSpellOutMode("")

            m.assertEqual(result, "")
        end function

        @it("processSpellOutMode handles mixed alphanumeric text")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            result = ttsService.processSpellOutMode("A1B2")

            m.assertEqual(result, "A 1 B 2")
        end function

        @describe("symbol dictionary customization")

        @it("setSymbolDictionary updates dictionary and affects spellOut")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Set Hungarian localization
            ttsService.setSymbolDictionary({
                "@": "kukac",
                ".": "pont"
            })

            result = ttsService.processSpellOutMode("@.")

            m.assertEqual(result, "kukac pont")
        end function

        @describe("service state management")

        @it("enable method sets isEnabled to true")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            initialState = ttsService.isEnabled

            ' Enable service
            ttsService.enable()

            ' Should be enabled (if device supports AudioGuide)
            ' In test environment this depends on device
            m.assertNotInvalid(ttsService.isEnabled)
        end function

        @it("disable method sets isEnabled to false")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Disable service
            ttsService.disable()

            ' Should be disabled
            m.assertFalse(ttsService.isEnabled)
        end function

        @it("toggleAudioGuide toggles state when called without parameters")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Get initial state
            initialState = ttsService.isEnabled

            ' Toggle state
            newState = ttsService.toggleAudioGuide()

            ' State should have changed (if device supports AudioGuide)
            ' In test environment this depends on device
            m.assertNotInvalid(newState)
        end function

        @it("toggleAudioGuide sets explicit state when parameter provided")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Set explicit false
            result = ttsService.toggleAudioGuide(false)

            ' Should return false
            m.assertFalse(result)
            m.assertFalse(ttsService.isEnabled)

            ' Set explicit true
            result = ttsService.toggleAudioGuide(true)

            ' Should return true (if device supports AudioGuide)
            m.assertNotInvalid(result)
        end function

        @it("stopSpeech clears pending speech and override flag")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Call stopSpeech
            ttsService.stopSpeech()

            ' Verify flags are cleared
            m.assertInvalid(ttsService.pendingSpeech)
            m.assertFalse(ttsService.overrideNextFlushFlag)
        end function

        @describe("edge cases")

        @it("processSpellOutMode handles special characters and spaces")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            result = ttsService.processSpellOutMode("test_file-name.txt")

            ' Should spell out with symbol replacements
            m.assertTrue(Len(result) > 10)
            m.assertTrue(result.Instr("underscore") > 0)
            m.assertTrue(result.Instr("dash") > 0)
            m.assertTrue(result.Instr("dot") > 0)
        end function

        @it("speak handles empty say parameter gracefully")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Should not crash with empty string
            ttsService.speak({
                say: ""
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("speak handles invalid config gracefully")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Should not crash with invalid say
            ttsService.speak({})

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @describe("dontRepeat functionality")

        @it("dontRepeat skips duplicate speech")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' First call - should set lastSpeech
            ttsService.speak({
                say: "Test message",
                dontRepeat: true
            })

            ' Store lastSpeech value
            firstLastSpeech = ttsService.lastSpeech

            ' Second call with same text and dontRepeat
            ttsService.speak({
                say: "Test message",
                dontRepeat: true
            })

            ' lastSpeech should remain the same (duplicate was skipped)
            m.assertEqual(ttsService.lastSpeech, firstLastSpeech)
        end function

        @it("dontRepeat false allows duplicate speech")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Call without dontRepeat - should not skip
            ttsService.speak({
                say: "Test message",
                dontRepeat: false
            })

            ' Second call should also execute (no skip)
            ttsService.speak({
                say: "Test message",
                dontRepeat: false
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @describe("overrideNextFlush functionality")

        @it("overrideNextFlush protects speech from being flushed")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Speak with override protection
            ttsService.speak({
                say: "Protected message",
                overrideNextFlush: true,
                flush: true
            })

            ' Flag should be set
            m.assertTrue(ttsService.overrideNextFlushFlag)

            ' Next flush should clear the flag
            ttsService.speak({
                say: "New message",
                flush: true
            })

            ' Flag should now be cleared
            m.assertFalse(ttsService.overrideNextFlushFlag)
        end function

        @it("overrideNextFlush false does not set protection")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Speak without override protection
            ttsService.speak({
                say: "Unprotected message",
                overrideNextFlush: false,
                flush: true
            })

            ' Flag should remain false
            m.assertFalse(ttsService.overrideNextFlushFlag)
        end function

        @describe("combination tests")

        @it("speak with flush and spellOut combination")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Should not crash with combined options
            ttsService.speak({
                say: "ABC123",
                flush: true,
                spellOut: true
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("speak with flush and dontRepeat combination")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' First call with flush and dontRepeat
            ttsService.speak({
                say: "Combined test",
                flush: true,
                dontRepeat: true
            })

            ' Second call should be skipped by dontRepeat
            ttsService.speak({
                say: "Combined test",
                flush: true,
                dontRepeat: true
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @it("speak with all options enabled")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Should handle all options together
            ttsService.speak({
                say: "Full test",
                flush: true,
                spellOut: true,
                overrideNextFlush: true,
                dontRepeat: true
            })

            ' Test passes if no crash
            m.assertTrue(true)
        end function

        @describe("pending speech management")

        @it("speak without flush stores speech as pending")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Speak without flush - should be pending
            ttsService.speak({
                say: "Pending message"
            })

            ' If enabled, pendingSpeech should be set
            ' If disabled, pendingSpeech remains invalid
            ' Just verify the service handled it
            m.assertNotInvalid(ttsService)
        end function

        @it("speak with flush clears pending speech")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' First speak without flush to set pending
            ttsService.speak({
                say: "Pending message"
            })

            ' Then flush - should clear pending
            ttsService.speak({
                say: "Flush message",
                flush: true
            })

            ' Pending should be cleared by flush
            ' (if service was enabled and executed)
            m.assertNotInvalid(ttsService)
        end function

        @describe("lastSpeech tracking")

        @it("lastSpeech is updated after speaking")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()
            initialLastSpeech = ttsService.lastSpeech

            ' Speak to update lastSpeech
            ttsService.speak({
                say: "Track this",
                flush: true
            })

            ' If service is enabled, lastSpeech might be updated
            ' If disabled, it remains unchanged
            ' Just verify service exists
            m.assertNotInvalid(ttsService.lastSpeech)
        end function

        @it("lastSpeech can be empty initially")
        function _()
            widget = m.fwInstance.getWidget("testLabel")
            m.assertNotInvalid(widget)

            ttsService = widget.tts()

            ' Initial lastSpeech should be empty string
            m.assertEqual(ttsService.lastSpeech, "")
        end function

    end class
end namespace
