```yaml
ctx: ViewModel Reference
type: component-state container
scope:
  baseClass: Rotor.ViewModel
  usage: "Group multiple widgets with shared props and viewModelState. Separates presentation logic from business logic."
  description: "Extends base Widget class to group multiple widgets with shared state and behavior. Encapsulates both widget tree structure and state management."
core:
  coreMethods:
    template:
      required: true
      syntax: "override function template() as object"
      description: "Returns widget tree configuration object. Called once during ViewModel creation."
    setProps:
      required: false
      syntax: "override sub setProps(newProps as object)"
      description: "Updates ViewModel's props. Triggers onUpdateView() as default."
  lifecycleHooks:
    onCreateView:
      whenCalled: "After ViewModel creation, before template()"
      purpose: "Initialize state, setup listeners, configure initial values"
      override: true
    onTemplateCreated:
      whenCalled: "After template() returns, before rendering"
      purpose: "Access rendered widgets, setup widget-specific logic"
      override: true
    onUpdateView:
      whenCalled: "When ViewModel updates (after setProps or update props via render)"
      purpose: "React to prop changes, update state based on new props"
      override: true
      important: "Framework intentionally does NOT automatically re-render UI when ViewModel receives new props via render() or setProps(). This design optimizes for Roku's resource constraints and allows use-case-specific performance optimizations. Override onUpdateView() to implement custom UI update logic based on prop changes—you control exactly which widgets update and when. This does NOT affect initial rendering—UI is rendered normally based on template() using initial props and viewModelState values. onUpdateView() specifically handles subsequent updates after ViewModel is already mounted and displayed."
    onDestroyView:
      whenCalled: "Before ViewModel destruction"
      purpose: "Cleanup resources, remove listeners, clear references"
      override: true
  sharedProperties:
    props:
      scope: "All widgets in ViewModel"
      mutability: "Read-only"
      description: "Configuration passed during render, available as m.props in all widgets"
    viewModelState:
      scope: "All widgets in ViewModel"
      mutability: "Mutable"
      description: "Shared state, available as m.viewModelState in all widgets"
howItWorks:
  workflow:
    - step: "ViewModel class is instantiated"
    - step: "ViewModel's root widget is added to virtual tree"
    - step: "Default props and viewModelState are extended from config"
    - step: "Widget is decorated with framework methods and plugins"
    - step: "onCreateView() is called (if defined)"
    - step: "template() is called to get widget tree configuration"
    - step: "Plugins are applied to configure widget behavior (fields, focus, observer, etc.)"
    - step: "All child widgets in the tree share the same props and viewModelState references"
    - step: "Widgets can access m.props and m.viewModelState in field expressions and hooks"
    - step: "When ViewModel is destroyed, onDestroyView() is called and references are cleared"
structure:
  classDefinition: |
    class MyViewModel extends Rotor.ViewModel
      ' Shared configuration (default, extended via config)
      props = {}

      ' Shared mutable state (default, extended via config)
      viewModelState = {}

      ' Required: Returns widget tree configuration
      override function template() as object
        return { ... }
      end function

      ' Lifecycle hooks (optional)
      override sub onCreateView()
      override sub onTemplateCreated()
      override sub onUpdateView()
      override sub onDestroyView()

      ' Method for updating props
      override sub setProps(newProps as object)
    end class
example:
  fullExample: |
    class ButtonViewModel extends Rotor.ViewModel

      props = {
        label: "Click Me",
        enabled: true
      }

      viewModelState = {
        isFocused: false,
        clickCount: 0
      }

      override function template() as object
        return {
          nodeType: "Group",
          children: [{
            id: "background",
            nodeType: "Rectangle",
            fields: {
              width: 200,
              height: 60,
              color: function() as string
                typecast m as Rotor.ViewModel
                if m.viewModelState.isFocused
                  return "#FF5500"
                else if m.props.enabled
                  return "#0055FF"
                else
                  return "#CCCCCC"
                end if
              end function
            }
          }, {
            id: "text",
            nodeType: "Label",
            fields: {
              text: m.props.label,
              width: 200,
              height: 60,
              horizAlign: "center",
              vertAlign: "center",
              color: "#FFFFFF"
            }
          }]
        }
      end function

      override sub onCreateView()
        print "ButtonViewModel created"

        ' Access dispatcher state using getState helper (available in ViewModels)
        dispatcher = m.getDispatcher("appState")
        currentState = dispatcher.getState()

        ' Or use m.getStateFrom() convenience method
        currentState = m.getStateFrom("appState")
      end sub

    end class

    ' Render the ViewModel
    frameworkInstance.render({
      viewModel: ButtonViewModel
    })
patterns:
  buttonExample: "Template returns Group with Rectangle + Label. Background color responds to props.enabled and viewModelState.isFocused."
  stateSharing: "Child widgets access m.props and m.viewModelState for coordinated updates. All children share same references."
  manualUpdates: "Override onUpdateView to control rerenders on prop changes. Framework does not auto re-render."
  propsConfiguration: "Pass props during render. Props are read-only within ViewModel."
  stateManagement: "Use viewModelState for mutable shared state. Initialize in onCreateView before template executes."
  dispatcherHelpers: "Use m.dispatchTo(id, intent) and m.getStateFrom(id) convenience methods for concise dispatcher access in ViewModels."
rules:
  - "Use template() to declare UI structure. Do not mutate props/viewModelState inside template()."
  - "Initialize required state fields in onCreateView before template() executes."
  - "Implement onUpdateView() to control post-mount updates. Framework will NOT automatically re-render on prop changes."
  - "Use props for read-only configuration. Use viewModelState for mutable shared state."
  - "Clean up resources in onDestroyView(). Invalidate listeners, references, timers."
  - "Declare lifecycle hooks with override keyword."
  - "Access props and viewModelState via m.props and m.viewModelState in child widgets."
bestPractices:
  templateStructure:
    - "template() must return a single top-level widget configuration object"
    - "The top widget in template shares the same scope (m) as the ViewModel class"
    - "All child widgets can access m.props and m.viewModelState"
  propsVsState:
    - "Use props for external data (from parent ViewModels, dispatchers, render calls)"
    - "Use viewModelState exclusively for internal ViewModel state"
    - "Treat props as read-only; use setProps() to update them"
  uiUpdates:
    - "Implement UI updates for both flows: initial (template) and update (onUpdateView)"
    - "setProps(newProps) appends props and automatically triggers onUpdateView()"
    - "Framework does NOT auto re-render on prop changes—you must implement onUpdateView()"
  publicMethods:
    - "Implement public methods on ViewModel classes for external interaction"
    - "Call via widget references: m.children.myChildViewModel.customMethod()"
  updateStrategies:
    - "render(): Re-render specific widget subtrees with new configurations"
    - "refresh(): Force re-evaluation of field expressions"
    - "Direct node manipulation: Modify m.node properties for simple updates"
    - "Choose based on complexity: render() for complex, direct manipulation for simple"
    - "Balance code readability vs runtime performance based on use case"
  general:
    - "Keep ViewModels focused on specific UI components or features"
    - "Initialize state in onCreateView before template executes"
    - "Clean up resources in onDestroyView to prevent memory leaks"
    - "Use type casting (typecast m as Rotor.ViewModel) in field functions"
    - "Use m.dispatchTo() and m.getStateFrom() for concise dispatcher interaction"
pitfalls:
  - "Forgetting to override onUpdateView means UI won't update on prop changes."
  - "Mutating props inside template or lifecycle hooks. Props are read-only."
  - "Not cleaning up listeners/resources in onDestroyView causes memory leaks."
  - "Assuming framework auto re-renders on prop changes. You must implement onUpdateView."
  - "Not initializing viewModelState fields before template executes can cause errors."
nextSteps:
  - "Fields Plugin: Field management with expressions and interpolation"
  - "ViewBuilder Overview: High-level architecture and concepts"
  - "Widget Reference: Complete Widget properties, methods, and usage patterns"
```
