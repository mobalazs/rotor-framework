```yaml
ctx: ViewModel Reference
type: component-state container
scope:
  baseClass: Rotor.ViewModel
  usage: "Group multiple widgets with shared props and viewModelState. Separates presentation logic from business logic."
  description: "Extends base Widget class to group multiple widgets with shared state and behavior. Encapsulates both widget tree structure and state management."
core:
  coreMethods:
    template:
      required: true
      syntax: "override function template() as object"
      description: "Returns widget tree configuration object. Called once during ViewModel creation."
    setProps:
      required: false
      syntax: "override sub setProps(newProps as object)"
      description: "Updates ViewModel's props. Triggers onUpdateView() as default."
  lifecycleHooks:
    onCreateView:
      whenCalled: "After ViewModel creation, before template()"
      purpose: "Initialize state, setup listeners, configure initial values"
      override: true
    onTemplateCreated:
      whenCalled: "After template() returns, before rendering"
      purpose: "Access rendered widgets, setup widget-specific logic"
      override: true
    onUpdateView:
      whenCalled: "When ViewModel updates (after setProps or update props via render)"
      purpose: "React to prop changes, re-render template by default"
      override: true
      defaultBehavior: "Calls m.render() which re-renders using template(). Override to customize: skip render for performance, add custom logic, or render partial updates."
      important: "By default onUpdateView() calls m.render(). When m.render() is called without arguments on a ViewModel, it automatically calls m.template() and re-renders with the result."
    onDestroyView:
      whenCalled: "Before ViewModel destruction"
      purpose: "Cleanup resources, remove listeners, clear references"
      override: true
  sharedProperties:
    props:
      scope: "All widgets in ViewModel"
      mutability: "Read-only"
      description: "Configuration passed during render, available as m.props in all widgets"
    viewModelState:
      scope: "All widgets in ViewModel"
      mutability: "Mutable"
      description: "Shared state, available as m.viewModelState in all widgets"
howItWorks:
  workflow:
    - step: "ViewModel class is instantiated"
    - step: "ViewModel's root widget is added to virtual tree"
    - step: "Default props and viewModelState are extended from config"
    - step: "Widget is decorated with framework methods and plugins"
    - step: "onCreateView() is called (if defined)"
    - step: "template() is called to get widget tree configuration"
    - step: "Plugins are applied to configure widget behavior (fields, focus, observer, etc.)"
    - step: "All child widgets in the tree share the same props and viewModelState references"
    - step: "Widgets can access m.props and m.viewModelState in field expressions and hooks"
    - step: "When ViewModel is destroyed, onDestroyView() is called and references are cleared"
structure:
  classDefinition: |
    class MyViewModel extends Rotor.ViewModel
      ' Shared configuration (default, extended via config)
      props = {}

      ' Shared mutable state (default, extended via config)
      viewModelState = {}

      ' Required: Returns widget tree configuration
      override function template() as object
        return { ... }
      end function

      ' Lifecycle hooks (optional)
      override sub onCreateView()
      override sub onTemplateCreated()
      override sub onDestroyView()

      ' onUpdateView - has default implementation that calls m.render()
      override sub onUpdateView()
        ' Default: m.render() - re-renders using template()
      end sub

      ' Method for updating props - calls onUpdateView() after updating
      override sub setProps(newProps as object)
    end class
  renderBehavior:
    withoutArgs: "m.render() on ViewModel automatically calls m.template() and re-renders"
    withArgs: "m.render(partialTemplate) updates specific parts of the widget tree"
example:
  fullExample: |
    class ButtonViewModel extends Rotor.ViewModel

      props = {
        label: "Click Me",
        enabled: true
      }

      viewModelState = {
        isFocused: false,
        clickCount: 0
      }

      override function template() as object
        return {
          nodeType: "Group",
          children: [{
            id: "background",
            nodeType: "Rectangle",
            fields: {
              width: 200,
              height: 60,
              color: function() as string
                typecast m as Rotor.ViewModel
                if m.viewModelState.isFocused
                  return "#FF5500"
                else if m.props.enabled
                  return "#0055FF"
                else
                  return "#CCCCCC"
                end if
              end function
            }
          }, {
            id: "text",
            nodeType: "Label",
            fields: {
              text: m.props.label,
              width: 200,
              height: 60,
              horizAlign: "center",
              vertAlign: "center",
              color: "#FFFFFF"
            }
          }]
        }
      end function

      override sub onCreateView()
        print "ButtonViewModel created"

        ' Access dispatcher state using getState helper (available in ViewModels)
        dispatcher = m.getDispatcher("appState")
        currentState = dispatcher.getState()

        ' Or use m.getStateFrom() convenience method
        currentState = m.getStateFrom("appState")
      end sub

    end class

    ' Render the ViewModel
    frameworkInstance.render({
      viewModel: ButtonViewModel
    })
patterns:
  buttonExample: "Template returns Group with Rectangle + Label. Background color responds to props.enabled and viewModelState.isFocused."
  stateSharing: "Child widgets access m.props and m.viewModelState for coordinated updates. All children share same references."
  autoRerender: "Default onUpdateView() calls m.render() which re-renders template(). Override to customize or skip for performance."
  propsConfiguration: "Pass props during render. Props are read-only within ViewModel."
  stateManagement: "Use viewModelState for mutable shared state. Initialize in onCreateView before template executes."
  dispatcherHelpers: "Use m.dispatchTo(id, intent) and m.getStateFrom(id) convenience methods for concise dispatcher access in ViewModels."
rules:
  - "Use template() to declare UI structure. Do not mutate props/viewModelState inside template()."
  - "Initialize required state fields in onCreateView before template() executes."
  - "Default onUpdateView() calls m.render() for auto re-render. Override to customize behavior or optimize performance."
  - "m.render() without arguments on ViewModel automatically calls m.template() and re-renders."
  - "Use props for read-only configuration. Use viewModelState for mutable shared state."
  - "Clean up resources in onDestroyView(). Invalidate listeners, references, timers."
  - "Declare lifecycle hooks with override keyword."
  - "Access props and viewModelState via m.props and m.viewModelState in child widgets."
bestPractices:
  - "Keep ViewModels focused on specific UI components or features."
  - "Initialize state in onCreateView before template executes."
  - "Override onUpdateView() to optimize re-renders if full template refresh is too expensive."
  - "Clean up resources in onDestroyView to prevent memory leaks."
  - "Use props for configuration, viewModelState for internal mutable state."
  - "Use type casting (typecast m as Rotor.ViewModel) in field functions for correct context."
  - "Use m.dispatchTo() and m.getStateFrom() for concise dispatcher interaction."
pitfalls:
  - "Overriding onUpdateView() without calling m.render() means UI won't auto-update on prop changes."
  - "Mutating props inside template or lifecycle hooks. Props are read-only."
  - "Not cleaning up listeners/resources in onDestroyView causes memory leaks."
  - "Not initializing viewModelState fields before template executes can cause errors."
  - "Expensive template() with frequent setProps() calls - consider partial renders via m.render(partialTemplate)."
nextSteps:
  - "Fields Plugin: Field management with expressions and interpolation"
  - "ViewBuilder Overview: High-level architecture and concepts"
  - "Widget Reference: Complete Widget properties, methods, and usage patterns"
```
