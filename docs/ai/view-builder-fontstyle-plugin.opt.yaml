```yaml
ctx: ViewBuilder FontStyle Plugin
type: typography / label-styling
scope:
  nodeType: Label widgets only
  usage: "Declarative font management for Label nodes. Apply font styles via fontStyle property, supports static objects, @ operator resolution within properties, function expressions for conditional typography."

core:
  valueTypes:
    staticObject: "{ uri: 'pkg:/fonts/Roboto.ttf', size: 32 } - Direct font definition"
    atOperatorInProps: "{ uri: '@l10n.fonts.regular', size: '@fontSize' } - @ resolution within properties"
    functionExpression: "function() as object - Dynamic font selection based on state/props"
  features:
    - "Automatic font node creation and application during lifecycle"
    - "@ operator resolution within object properties (uri, size)"
    - "@l10n. prefix resolves from viewModelState.l10n"
    - "@ prefix resolves from viewModelState"
    - "Supports typecast m as Rotor.Widget for IDE tooling"
    - "Reusable typography systems via shared UI.fontStyles"

props:
  fontObject:
    uri: "string - Font file path or @ expression. Must resolve to TTF path."
    size: "integer or @ expression - Font size in pixels"
  contextAccess:
    viewModelState: "Source for @ operator resolution"
    viewModelState.l10n: "Source for @l10n. prefix resolution"
    props: "Conditional font selection based on widget properties"

expressionSyntax:
  atL10nPrefix: "@l10n.key.path - Resolves from widget.viewModelState.l10n"
  atPrefix: "@key.path - Resolves from widget.viewModelState"

valueTypes:
  staticFont: |
    fontStyle: { uri: "pkg:/fonts/Roboto-Bold.ttf", size: 48 }
  atOperatorInProps: |
    ' @l10n. resolves from viewModelState.l10n
    fontStyle: { uri: "@l10n.fonts.regular", size: 24 }
    ' @ resolves from viewModelState
    m.viewModelState.fontUri = "pkg:/fonts/Roboto.ttf"
    m.viewModelState.fontSize = 32
    fontStyle: { uri: "@fontUri", size: "@fontSize" }
  functionExpression: |
    fontStyle: function() as object typecast m as Rotor.Widget
      if m.viewModelState.isHighlighted
        return { uri: "pkg:/fonts/Roboto-Bold.ttf", size: 36 }
      else
        return { uri: "pkg:/fonts/Roboto-Regular.ttf", size: 32 }
      end if
    end function

typecast:
  feature: "BrighterScript V1 feature for IDE type information"
  optional: "No runtime effect, only improves IDE experience"
  usage: "function() as object typecast m as Rotor.Widget"
  note: "Use for autocomplete and type safety during development"

lifecycle:
  beforeMount: "Resolve fontStyle value and apply initial font to Label node"
  beforeUpdate: "Reapply font if fontStyle configuration changes"
  beforeDestroy: "Clear font node references (automatic cleanup)"

pipeline:
  1: "Confirm widget is Label (fontStyle ignored on other node types)"
  2: "Resolve fontStyle value (static object, @ operator, or function)"
  3: "Evaluate expressions with widget context (m.viewModelState, m.props)"
  4: "Create or reuse Font node with uri and size"
  5: "Assign Font node to Label.node.font"
  6: "Reapply on updates when fontStyle changes"

patterns:
  l10nFontResolution: |
    ' Localized font resolution from viewModelState.l10n
    m.viewModelState.l10n = {
      fonts: {
        regular: "pkg:/fonts/Roboto-Regular.ttf",
        bold: "pkg:/fonts/Roboto-Bold.ttf"
      }
    }
    fontStyle: { uri: "@l10n.fonts.regular", size: 24 }
  viewModelStateResolution: |
    ' Font properties from viewModelState
    m.viewModelState.fontUri = "pkg:/fonts/Roboto-Bold.ttf"
    m.viewModelState.fontSize = 32
    fontStyle: { uri: "@fontUri", size: "@fontSize" }
  typographySystem: |
    UI.fontStyles = {
      h1: { uri: "pkg:/fonts/Roboto-Bold.ttf", size: 48 }
      h2: { uri: "pkg:/fonts/Roboto-Bold.ttf", size: 36 }
      body: { uri: "pkg:/fonts/Roboto-Regular.ttf", size: 24 }
      caption: { uri: "pkg:/fonts/Roboto-Light.ttf", size: 18 }
    }
    fontStyle: UI.fontStyles.h1
  dynamicStateSelection: |
    fontStyle: function() as object
      if m.viewModelState.isSelected
        return { uri: "pkg:/fonts/Roboto-Bold.ttf", size: 32 }
      else if m.viewModelState.isDisabled
        return { uri: "pkg:/fonts/Roboto-Light.ttf", size: 28 }
      else
        return { uri: "pkg:/fonts/Roboto-Regular.ttf", size: 30 }
      end if
    end function
  propsBasedFont: |
    fontStyle: function() as object
      if m.props.category = "title"
        return { uri: "pkg:/fonts/Roboto-Bold.ttf", size: 48 }
      else if m.props.category = "subtitle"
        return { uri: "pkg:/fonts/Roboto-Medium.ttf", size: 32 }
      else
        return { uri: "pkg:/fonts/Roboto-Regular.ttf", size: 24 }
      end if
    end function
  highlightOnFocus: |
    fontStyle: function() as object
      if m.viewModelState.isFocused
        return { uri: "pkg:/fonts/Roboto-Bold.ttf", size: 36 }  (bold when focused)
      else
        return { uri: "pkg:/fonts/Roboto-Regular.ttf", size: 32 }
      end if
    end function

bestPractices:
  reuseTypographySystem: "Define centralized UI.fontStyles. Reuse font objects to avoid redundant Font node creation."
  useFunctionExpressionsForConditional: "Dynamic font switching based on state. Cleaner than manual updates."
  limitFontVariants: "Limit to essential font set for performance. Loading many fonts increases memory usage."
  preloadFonts: "Load essential fonts early in app lifecycle to avoid delays."

pitfalls:
  nonLabelNodeTypes: "fontStyle ignored on non-Label nodes. Solution: Only apply to Label nodeType."
  missingFontFiles: "Missing font files cause runtime errors. Solution: Verify pkg:/fonts/ structure before deployment."
  unsupportedFormats: "Non-TTF formats fail to load. Solution: Use TTF format only."
  unnecessaryFontCreation: "Creating new font objects on every render. Solution: Cache font objects in viewModelState or UI.fontStyles."
  functionScopeIssues: "Function expressions lacking widget scope. Solution: Add typecast m as Rotor.Widget if needed."
  atOperatorInWrongContext: "Using @l10n. when l10n not set in viewModelState. Solution: Ensure viewModelState.l10n exists."

troubleshooting:
  fontNotApplying:
    checks:
      - "Verify widget nodeType is Label"
      - "Check font file exists at uri path"
      - "Inspect widget.node.font to see applied font"
      - "Print fontStyle config: FormatJson(widget.fontStyle)"
    debug: |
      sub debugFont(widget as object)
        if widget.nodeType <> "Label"
          print "ERROR: fontStyle only works on Label nodes"
        print "FontStyle config: " + FormatJson(widget.fontStyle)
        if widget.node.font <> invalid
          print "Applied font uri: " + widget.node.font.uri
          print "Applied font size: " + widget.node.font.size.toStr()
        else
          print "ERROR: No font applied to node"
  atOperatorNotWorking:
    - "For @l10n.key: Check viewModelState.l10n.key exists"
    - "For @key: Check viewModelState.key exists"
    - "Verify @ is inside property value: { uri: '@fontUri', size: '@fontSize' }"
    - "Ensure resolved value is correct type (string for uri, integer for size)"
  performanceIssues:
    - "Profile font loading: Measure font file load times"
    - "Preload essential fonts: Load in app initialization"
    - "Cache style objects: Store in UI.fontStyles or viewModelState"
    - "Limit font variants: Use only necessary font weights/sizes"

fontManagement:
  supportedFormats: "TTF (TrueType Font) only"
  fontLocation: "pkg:/fonts/ directory recommended"
  fontNode: "Font SceneGraph node created automatically by plugin"
  caching: "Reuse font objects across widgets to avoid duplicate Font nodes"

api:
  fontApplication: "Font node assigned to Label.node.font"
  updateTrigger: "Font re-applied when widget.render() called with fontStyle changes"
  scopeBinding: "Function expressions executed with m = widget (bound scope)"
```
