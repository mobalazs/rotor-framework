```yaml
ctx: Internationalization (i18n) Support
type: localization / translation
scope:
  service: Rotor Framework I18nService
  consumers:
    - ViewModels via i18n template sections
    - Widget fields using @l10n references
  features:
    - "Multi-language support with nested translation structures"
    - "Automatic ViewModel integration with viewModelState.l10n"
    - "Variable interpolation with @l10n references"
    - "Dynamic key path resolution"
    - "Translation caching for performance"
    - "RTL language detection (Arabic, Hebrew, Persian, Urdu)"
core:
  translationStructure: |
    BrightScript associative arrays with locale-rooted structure:
    {
      "en_US": {
        "app": { "title": "My Application", "version": "1.0.0" },
        "navigation": { "home": "Home", "settings": "Settings" },
        "buttons": { "save": "Save", "cancel": "Cancel" }
      },
      "es_ES": {
        "app": { "title": "Mi Aplicación", "version": "1.0.0" },
        "navigation": { "home": "Inicio", "settings": "Configuración" },
        "buttons": { "save": "Guardar", "cancel": "Cancelar" }
      }
    }
  initialization: |
    sub init()
      m.framework = new Rotor.Framework()
      translations = getTranslations()
      currentLocale = "en_US"
      m.framework.i18nService.setL10n(translations[currentLocale])
    end sub
api:
  setL10n:
    syntax: "i18nService.setL10n(translations[locale])"
    description: "Load translations for active locale. Call during app init."
  getL10n:
    syntax: "i18nService.getL10n([keyPath])"
    description: "Fetch full bundle or nested key paths. Can pass string or array of paths to merge sections."
  setLocale:
    syntax: "i18nService.setLocale(locale)"
    description: "Switch locale. Runtime switching limited - prefer setting at startup."
  getLocale:
    syntax: "i18nService.getLocale()"
    description: "Get current locale string (e.g., 'en_US')."
  getIsRtl:
    syntax: "i18nService.getIsRtl()"
    description: "Return RTL boolean. Auto-detected based on locale (ar, he, fa, ur)."
  extendL10n:
    syntax: "i18nService.extendL10n(additionalTranslations)"
    description: "Extend existing translations with additional sections."
  ViewModelConfig:
    default: "All widgets have viewModelState.l10n with full translation object. Always use full paths like @l10n.navigation.home"
  widgetDecorators: "Service getter injected DIRECTLY onto widget (NOT under widget.plugins)"
  serviceAccess:
    widget.i18n: "widget.i18n() - Returns i18nService instance. Available on all widgets as decorator method."
    widget.i18n().getLocale: "widget.i18n().getLocale() - Returns current locale string (e.g., 'en_US')."
    widget.i18n().getIsRtl: "widget.i18n().getIsRtl() - Returns boolean RTL status for current locale."
  deprecatedMethods: "widget.getLocale() and widget.isRtl() REMOVED. Use widget.i18n().getLocale() and widget.i18n().getIsRtl() instead."
viewModelIntegration:
  defaultAccess: |
    ' ALL widgets have viewModelState.l10n automatically - use full paths
    class NavigationMenu extends Rotor.ViewModel
      override function template() as object
        return {
          nodeType: "Group",
          children: [{
            nodeType: "Label",
            fields: { text: m.viewModelState.l10n.navigation.home }
          }, {
            nodeType: "Label",
            fields: { text: m.viewModelState.l10n.buttons.save }
          }]
        }
      end function
    end class
  localeAccess: |
    override sub onCreateView()
      ' Access locale and RTL via i18n service (always available)
      i18n = m.i18n()
      currentLocale = i18n.getLocale()  ' "en_US"
      isRTL = i18n.getIsRtl()           ' false for LTR, true for RTL
    end sub
variableInterpolation:
  defaultBehavior: |
    @l10n references the full translation object. Always use complete paths:
    { fields: { text: "@l10n.app.title" } }
    { fields: { text: "@l10n.navigation.home" } }
  staticKeyReferences: |
    { fields: { text: "@l10n.app.title" } }
  dynamicKeyPaths: |
    class MenuItem extends Rotor.ViewModel
      override function template() as object
        return {
          nodeType: "Label",
          fields: { text: `@l10n.navigation.${m.props.menuKey}` }
        }
      end function
    end class
    Usage: { viewModel: ViewModels.MenuItem, props: { menuKey: "home" } }
  multipleReferences: |
    { fields: { text: `@l10n.app.title - @l10n.app.version` } }
  nestedInterpolation: |
    {
      fields: { text: `@l10n.messages.${m.props.messageType}.${m.props.severity}` }
    }
directAccess:
  inViewModels: |
    class ConfirmDialog extends Rotor.ViewModel
      override sub onCreateView()
        titleText = m.viewModelState.l10n.dialog.title
        messageText = m.viewModelState.l10n.dialog.message
        buttonText = m.viewModelState.l10n.buttons.save
      end sub
      override function template() as object
        return {
          nodeType: "Group",
          children: [{
            nodeType: "Label",
            fields: {
              text: function() as string
                if m.props.isError
                  return m.viewModelState.l10n.dialog.errorTitle
                else
                  return m.viewModelState.l10n.dialog.title
                end if
              end function
            }
          }]
        }
      end function
    end class
patterns:
  menuSystem: |
    class Menu extends Rotor.ViewModel
      override function template() as object
        menuItems = ["home", "settings", "about"]
        children = []
        for each itemKey in menuItems
          children.push({
            viewModel: ViewModels.MenuItem,
            props: { itemKey: itemKey }
          })
        end for
        return { nodeType: "Group", children: children }
      end function
    end class
  buttonLabels: |
    {
      nodeType: "Group",
      children: [
        { viewModel: ViewModels.Button, props: { label: "@l10n.buttons.save" } },
        { viewModel: ViewModels.Button, props: { label: "@l10n.buttons.cancel" } }
      ]
    }
  conditionalLocalization: |
    {
      fields: {
        text: function() as string
          if m.props.isLoading
            return m.viewModelState.l10n.messages.loading
          else if m.props.hasError
            return m.viewModelState.l10n.messages.error
          else
            return m.viewModelState.l10n.messages.welcome
          end if
        end function
      }
    }
rtlSupport:
  detection: "Framework auto-detects RTL for ar (Arabic), he (Hebrew), fa (Persian), ur (Urdu) locales."
  usage: |
    i18nService.setLocale("ar_SA")
    isRTL = i18nService.getIsRtl()  ' Returns true

    ' Access RTL status in ViewModel via i18n service getter
    override sub onCreateView()
      i18n = m.i18n()
      if i18n.getIsRtl()
        ' Apply RTL-specific layout adjustments
      else
        ' Apply LTR layout
      end if
    end sub

    ' Or in template field functions
    {
      nodeType: "Label",
      fields: {
        horizAlign: function() as string
          return m.i18n().getIsRtl() ? "right" : "left"
        end function
      }
    }
  note: "RTL detection implemented. Full RTL layout mirroring requires application-level implementation."
bestPractices:
  - "Organize translations hierarchically (ui.forms.login vs flat loginUsername)."
  - "Define translations per locale; keep keys consistent across locales."
  - "Initialize i18nService with current locale before rendering ViewModels."
  - "Load only required locale at startup for performance."
  - "Prefer template string interpolation for dynamic keys."
  - "Use dynamic keys for reusable components (@l10n.status.${m.props.statusType})."
  - "For RTL locales, use widget.i18n().getIsRtl() to check RTL status dynamically."
  - "Use widget.i18n().getLocale() and widget.i18n().getIsRtl() for dynamic locale/RTL access (not stored in viewModelState)."
rules:
  - "Define translations per locale; keep keys consistent across locales."
  - "Initialize i18nService with current locale before rendering ViewModels."
  - "Load only required locale at startup for performance."
  - "Prefer template string interpolation for dynamic keys: `@l10n.${m.props.key}`"
  - "For RTL locales, use widget.i18n().getIsRtl() method to check RTL status dynamically."
  - "Use widget.i18n().getLocale() and widget.i18n().getIsRtl() service getters (NOT widget.getLocale()/widget.isRtl() - those are removed)."
  - "Set locale during app init; runtime switching not fully implemented."
limitations:
  runtimeLocaleSwitching: "Changing locale at runtime not fully implemented. Set locale during app init."
  advancedFormatting: "Currency, date/time, number formatting with locale-specific separators not available."
  pluralForms: "Plural forms handling not implemented."
pitfalls:
  - "Runtime locale switching not fully implemented; set locale at startup."
  - "Advanced formatting (currency/date/number pluralization) unsupported."
  - "Missing translations lead to undefined keys; debug via getL10n()."
  - "Variable interpolation fails if key path or template syntax incorrect."
  - "Ensure @l10n references are in template strings: `@l10n.key` not @l10n.key"
troubleshooting:
  missingTranslation: |
    sub debugTranslation(keyPath as string)
      i18nService = m.framework.i18nService
      fullL10n = i18nService.getL10n()
      print "Translation keys:"
      for each key in fullL10n
        print "  " + key
      end for
      result = i18nService.getL10n(keyPath)
      print "Path '" + keyPath + "': " + FormatJson(result)
    end sub
  interpolationNotWorking:
    - "Check @l10n reference is in template string: `@l10n.key`"
    - "Verify key path exists in translation file"
    - "Confirm translation is loaded via i18nService.setL10n()"
    - "Check translation is available (inspect viewModelState.l10n)"
  performanceIssues:
    - "Load only required locale at startup"
    - "Cache frequently accessed translation values in ViewModel state"
    - "Avoid complex nested key resolution in frequently called functions"
lifecycle:
  - "Load translation bundles from source"
  - "Call setL10n(localeBundle) with active locale"
  - "Bind @l10n field references during render"
  - "Access translations in ViewModel via viewModelState.l10n"
  - "Optional RTL/layout adjustments based on isRTL flag"
pipeline:
  - "Fetch translations for current locale"
  - "Set locale bundle via i18nService.setL10n()"
  - "Render fields with @l10n references"
  - "Access full l10n object via viewModelState.l10n"
  - "Optional RTL/layout adjustments"
```
