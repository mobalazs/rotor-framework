```yaml
ctx: Widget Reference
type: widget-definition / API
scope:
  unit: Rotor Framework widget describing SceneGraph node + behavior
  usage: Declarative BrightScript configuration rendered via ViewBuilder
core:
  properties:
    id: "Optional unique identifier; autogenerated among siblings if omitted."
    nodeType: "SceneGraph node name (default \"Group\")."
    viewModel: "Optional ViewModel class reference."
    props: "Initial props passed to ViewModel."
    viewModelState: "Initial shared state."
    children: "Array/object defining child widgets."
    zIndex: "Rendering order among siblings."
  lifecycleHooks:
    - onMountWidget
    - onUpdateWidget
    - onDestroyWidget
    - onRenderSettled
  i18nConfig:
    path: "Single translation branch."
    paths: "Multiple branches."
    includeIsRtl: "Expose RTL flag."
    includeLocale: "Expose locale string."
api:
  frameworkAccess:
    getFrameworkInstance: "Return framework."
    getInfo: "Device and framework info."
  navigation:
    getWidget(id/path): "Locate widget by ID or path."
    getSiblingWidget(id): "Direct sibling lookup."
    getViewModel(): "Current ViewModel."
    getParentViewModel(): "Parent ViewModel."
    getRootWidget(): "Root widget node."
    findWidgets(pattern): "Pattern search."
    getChildrenWidgets(pattern?): "Direct children optionally filtered."
    getSubtreeClone(pattern?, keyPaths?): "Clone widget subtree."
  rendering:
    render(payloads, params?): "Create/update widgets."
    refresh(keyPaths?): "Refresh features (fields, focus, etc.)."
    erase(payloads, skipPool?): "Destroy widgets."
  stateManagement:
    getDispatcher(id): "Retrieve dispatcher."
    createDispatcher(id, model, reducer): "Instantiate dispatcher."
  animation:
    animator(id): "Access animator factory."
patterns:
  simpleWidget: "Label with static text/color."
  widgetWithChildren: "Parent Rectangle containing Label + Button."
  viewModelIntegration: "Render ViewModel and bind child widgets to state/props."
  navigationHelpers: "getWidget('path'), findWidgets('item-*')."
  listRendering: "Generate children array and render via m.render."
  dynamicChildren: "Update child list and rerender container widget."
rules:
  - "Use render/refresh instead of direct node mutation for consistency."
  - "Leverage lifecycle hooks for resource setup/cleanup; avoid heavy work in onMount."
  - "Use getWidget for known IDs; reserve findWidgets for patterns."
  - "Dispatch intents for state changes rather than mutating viewModelState directly."
  - "Ensure nodes exist before accessing fields; validate via getChildrenWidgets when debugging."
pitfalls:
  - "Pattern search for known IDs is inefficient."
  - "Mutating viewModelState directly bypasses dispatcher flow."
  - "Forgetting to clean up listeners/resources in onDestroyWidget."
  - "Assuming lifecycle hooks fire without assigning functions in config."
troubleshooting:
  widgetNotFound: "Use getWidget, list children to verify IDs."
  debugHierarchy: "Inspect parent via getWidget('../')."
  lifecycleIssues: "Confirm hook assignment and execution order."
  stateManagement: "Check dispatcher existence, listener wiring, memory invalidation."
lifecycle:
  - configure widget object
  - register in virtual tree with HID
  - apply plugins
  - onMountWidget -> onRenderSettled
  - onUpdateWidget on config changes
  - onDestroyWidget before removal
pipeline:
  - declare widget config
  - resolve children/ViewModel
  - apply plugins (fields, focus, font, observer, dispatcher)
  - materialize SceneGraph node
  - respond to render/refresh/erase calls
  - teardown via lifecycle hooks
```
