```yaml
ctx: ViewBuilder Observer Plugin
type: node field observation
scope:
  nodes: SceneGraph widgets with observer configuration
  usage: "Declarative field observation for SceneGraph nodes. Monitors node field changes through observer config, supports single/multiple observers per widget, callback routing, automatic lifecycle management."

core:
  configuration:
    single_callback: "observer: { fieldId: 'text', callback: sub(payload) ... end sub }"
    single_handler: "observer: { fieldId: 'renderTracking', handler: sub() ... end sub }"
    multi: "observer: [ { fieldId: 'state', callback: ... }, { fieldId: 'fire', handler: ... } ]"
  valueTypes:
    singleObject: "One observer per widget"
    array: "Multiple observers per widget"

props:
  required:
    fieldId: "string - Name of SceneGraph field to observe"
    callback: "function - Called WITH parsed payload. sub(payload) or sub(payload) typecast m as Rotor.Widget. Mutually exclusive with handler."
    handler: "function - Called WITHOUT arguments. sub() or sub() typecast m as Rotor.Widget. Mutually exclusive with callback."
  requiredNote: "One of callback or handler is required. They are mutually exclusive. If neither is provided, the framework throws an error."
  optional:
    id: "string - Custom identifier for observer"
    value: "dynamic - Initial value to set on field"
    alwaysNotify: "boolean (default: true) - Trigger callback even if value unchanged"
    once: "boolean (default: false) - Remove observer after first callback"
    until: "function - Function returning true when observer should be removed"
    parsePayload: "function - Transform payload before passing to callback"
    infoFields: "array - Additional fields to include in callback payload"

typecast:
  feature: "BrighterScript V1 feature - provides type information to language server/IDE"
  optional: "Entirely optional, no runtime effect - only improves development experience"
  types: "Rotor.Widget, Rotor.ViewModel, or any class that extends them"
  benefits:
    - "IDE Autocomplete: IntelliSense for widget methods/properties"
    - "Type Safety: Catches type errors during development before runtime"
    - "Documentation: Makes code intent clearer"
  usage: "typecast m as Rotor.Widget inside callback for IDE support"
  note: "Without typecast, code works identically at runtime. Use only when needed for IDE support or team type safety."

lifecycle:
  beforeMount: "Register observers when widget mounts"
  beforeUpdate: "Detach old observers, register new observers"
  beforeDestroy: "Unobserve fields and cleanup observer instances"

pipeline:
  1: "Configuration Parse - plugin processes observer config (single object or array)"
  2: "Attachment ID Generation - unique ID created per node attachment"
  3: "Helper Interface Setup - internal field added to node for observer tracking"
  4: "Observer Registration - creates Observer instance, stores in ObserverStack"
  5: "Native Observation - calls node.observeFieldScoped() with routing info"
  6: "Callback Routing - field changes route to correct Observer via callback router"
  7: "Payload Processing - optional parsePayload transformation before callback"
  8: "Callback/Handler Execution - callback executed in widget scope with payload, or handler executed with no arguments"
  9: "Cleanup - observers automatically detached on widget destroy or update"

patterns:
  videoStateMonitoring: |
    observer: [
      { fieldId: "state", callback: sub(payload)
          if payload.state = "playing" -> m.node.visible = true
          else if payload.state = "finished" -> m.handleVideoFinished()
      },
      { fieldId: "position", callback: sub(payload) -> m.updateProgressBar(payload.position) }
    ]
  oneTimeObserver: |
    observer: { fieldId: "loadComplete", once: true, callback: sub(payload) -> print "Load complete!" }
    Callback fires once, then observer removed
  conditionalObserver: |
    observer: {
      fieldId: "state"
      until: function(payload) -> return payload.state = "finished" end function
      callback: sub(payload) -> m.updateAnimationState(payload.state)
    }
    Remove observer when animation finishes
  payloadTransformation: |
    observer: {
      fieldId: "text"
      parsePayload: function(payload) as object
        return { text: payload.text, length: Len(payload.text), timestamp: CreateObject("roDateTime").AsSeconds() }
      end function
      callback: sub(payload) -> print "Text: " + payload.text + " Length: " + payload.length.toStr()
    }
  initialFieldValue: |
    observer: {
      fieldId: "customState"
      value: "initial"  (sets field initial value)
      alwaysNotify: true  (triggers callback even if value unchanged)
      callback: sub(payload) -> print "State: " + payload.customState
    }
  renderTrackingAutoSize: |
    Requires: fields: { enableRenderTracking: true }
    observer: {
      fieldId: "renderTracking"
      handler: sub()
        textHeight = m.node.localBoundingRect().height
        m.getSiblingWidget("background").node.height = textHeight + 40
      end sub
    }
    Most common observer pattern. handler (not callback) for layout calculation.
  renderTrackingFullCheck: |
    observer: {
      fieldId: "renderTracking"
      callback: sub(payload)
        if payload?.renderTracking = "full" then m.startAnimation()
      end sub
    }
    Use callback to check renderTracking value ("full" = fully rendered)
  multipleObserversSameHandler: |
    autoSizeHandler = sub() -> recalculate layout
    observer: [
      { fieldId: "renderTracking", handler: autoSizeHandler },
      { fieldId: "text", handler: autoSizeHandler }
    ]
    Multiple fields trigger same handler for layout recalculation
  timerFireOneShot: |
    { nodeType: "Timer", fields: { repeat: false, duration: 2.0 } }
    observer: { fieldId: "fire", handler: sub() -> m.getViewModel().onDelayComplete() }
    handler (not callback) â€” fire value irrelevant
  timerFireRepeating: |
    { nodeType: "Timer", fields: { repeat: true, duration: 1.0 } }
    observer: { fieldId: "fire", handler: sub() -> m.getViewModel().updateDisplayedTime() }
    Repeating timer for periodic updates (clock, refresh)
  timerOnce: |
    observer: { fieldId: "fire", callback: m.onInitComplete, once: true }
    Combines once:true with timer for guaranteed single callback
  callbackWithPayload: |
    observer: {
      fieldId: "state"
      callback: sub(payload) -> if payload.state = "finished" then m.getViewModel().onVideoFinished()
    }
    callback called with parsed payload - use when you need the field value

bestPractices:
  useOnceForOneTime: "Use once: true for one-time events. Avoids manual cleanup and memory leaks."
  useParsePayloadToReduceComplexity: "Clean separation: parsePayload transforms data, callback uses transformed data. Reduces callback complexity."
  groupRelatedObservers: "Use array for related observers (state, position). Keeps observers together, prevents forgetting some."
  useUntilForConditional: "Automatic cleanup when condition met. Avoids manual condition checking in callback."
  useHandlerForNotifications: "Use handler for renderTracking, timer, and notification-style observers where the payload is irrelevant. Avoids unused parameters and makes intent clearer."
  useCallbackForValues: "Use callback when you need to inspect the changed value (video state, content changes, etc.)."
  omitParsePayloadWithHandler: "parsePayload still executes when handler is used, but its result is discarded. Omit parsePayload when using handler for clarity."

pitfalls:
  observingNonExistentFields: "Field doesn't exist on node type. Solution: Verify field exists for specific SceneGraph node type."
  memoryLeaks: "Forgetting cleanup outside plugin. Solution: Plugin handles cleanup automatically in lifecycle."
  callbackScopeIssues: "m context in callbacks unclear. Solution: Use typecast m as Rotor.Widget for type safety."
  missingCallbackOrHandler: "Observer configured without callback or handler. Solution: Provide one of callback or handler (mutually exclusive, one required)."
  crashOnCallbackWithNoParams: "Callback defined as sub() but configured with callback: instead of handler:. Crashes because framework passes payload argument. Solution: Switch to handler: for zero-argument callbacks."
  payloadStructureAssumptions: "Assuming payload format. Solution: Use parsePayload to normalize payload structure."
  heavyCallbackOperations: "Expensive operations in callbacks. Solution: Keep callbacks lightweight, defer heavy work."

troubleshooting:
  observerNotFiring:
    checks:
      - "Verify field exists: widget.node.hasField('yourFieldId')"
      - "Print observer config: FormatJson(widget.observer)"
      - "Check node type: widget.node.subtype()"
      - "Check current value: widget.node.getField('yourFieldId').toStr()"
    debug: |
      sub debugObserver(widget as object)
        print "Widget ID: " + widget.id
        print "Node Type: " + widget.nodeType
        print "Observer Config: " + FormatJson(widget.observer)
        if widget.node.hasField("yourFieldId")
          print "Field exists on node"
          print "Current value: " + widget.node.getField("yourFieldId").toStr()
        else
          print "ERROR: Field does not exist on node type " + widget.node.subtype()
  callbackNotExecuting:
    - "Check field name: Ensure fieldId matches exact SceneGraph field name"
    - "Verify node type: Confirm field exists for specific node type"
    - "Test field changes: Manually change field to verify observation works"
    - "Check callback function: Ensure callback is valid function reference"
    - "Inspect payload: Print payload in callback to see what's received"
  performanceIssues:
    - "Profile callbacks: Measure callback execution time"
    - "Reduce observer count: Combine related observations when possible"
    - "Optimize parsePayload: Keep payload processing minimal and fast"
    - "Use once and until: Remove observers when no longer needed"

state:
  helperInterface: "Per-node attachment ID stored to route callbacks"
  observerStack: "Manages Observer instances keyed by id/attachment"
  routing: "observerNativeCallback routes SceneGraph events to correct Observer instance"

api:
  nativeIntegration: "node.observeFieldScoped(fieldId, router, infoFields)"
  callbackScope: "Callbacks executed in widget scope (m = widget)"
  payloadFormat: "{ fieldId: value, ...infoFields }"
```
