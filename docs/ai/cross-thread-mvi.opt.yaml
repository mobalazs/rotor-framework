```yaml
ctx: Cross-Thread MVI Pattern
type: state-management / multi-thread
scope:
  threads:
    - render thread
    - task thread
  usage: Rotor Framework apps requiring synchronized state across threads
core:
  components:
    Model: "State container extending Model base class; declares initial state. Example: CounterModel with state = { count: 0, lastUpdated: invalid }"
    Reducer: "Transforms state via reducer() and optional applyMiddlewares(). Middleware runs before reducer for async operations."
    Dispatcher: "Bridge exposing createDispatcher, dispatch, getState, addListener. Connects Model and Reducer with thread-safe communication."
  flowDiagram: images/Rotor_Framework_cross-thread_MVI.jpeg
api:
  createDispatcher:
    syntax: "Rotor.createDispatcher(name, model, reducer)"
    description: "Register dispatcher with unique name, model, reducer. Task thread dispatchers are globally accessible. Render thread dispatchers are local-use only."
  dispatch:
    syntax: "dispatcher.dispatch({ type: intentType, payload: data })"
    description: "Send intents from any thread; payload optional. Triggers middleware then reducer."
  getState:
    syntax: "dispatcher.getState(sub(props, state) ... end sub)"
    description: "Callback receives current state snapshot; used for binding props. Executes callback with current state once. In reducers, use m.getState() helper to access current state directly."
  addListener:
    syntax: "dispatcher.addListener({ mapStateToProps, allowUpdate, callback, once })"
    description: "Subscribe to state changes. mapStateToProps updates props from state. allowUpdate filters when callback fires. callback or callbackWithState executes on update. once removes listener after first trigger."
  registerSourceObject:
    syntax: "m.registerSourceObject(typeName, eventFilter) as object"
    description: "Creates and registers a Roku source object by type name. Framework manages object creation, port assignment, and event routing. Task thread only. Takes typeName string (e.g. 'roUrlTransfer', 'roDeviceInfo') — framework calls CreateObject(typeName) internally. Returns the created (or shared) source object. Auto-detects routing mode: identity-based (GetIdentity, e.g. roUrlTransfer) creates new instance per call with 1:1 routing; broadcast (no GetIdentity, e.g. roDeviceInfo) is singleton per type — first call creates, subsequent calls return shared instance and add dispatcher as subscriber. Optional eventFilter function filters events. Events routed to onSourceEvent(). Available in BaseReducer."
  unregisterSourceObject:
    syntax: "m.unregisterSourceObject(sourceObject)"
    description: "Unregister a previously registered source object. Identity-based: removes by identity from registry. Broadcast: removes dispatcher subscriber; cleans up shared object when no subscribers remain. Available in BaseReducer."
  onCreateDispatcher:
    syntax: "override sub onCreateDispatcher()"
    description: "Lifecycle hook called after dispatcher is fully registered. Override to perform initialization that requires dispatcher to be set up (e.g., registering broadcast source objects like roDeviceInfo)."
state:
  renderThread:
    - "dispatch intent to task thread"
    - "listener callbacks receive state updates"
    - "UI update via render/refresh"
  taskThread:
    - "middleware execution (async operations, logging)"
    - "reducer state update (synchronous mutations)"
    - "sync back to listeners on render thread"
examples:
  modelDefinition: |
    class CounterModel extends Model
      state = { count: 0, lastUpdated: invalid }
    end class
  reducerDefinition: |
    class CounterReducer extends Reducer
      override function applyMiddlewares()
        return [
          function(intent, state) ' Logger
            return intent ' pass-through
          end function,
          function(intent, state) ' Async HTTP
            if intent.type = "LOAD_COUNT"
              transfer = m.registerSourceObject("roUrlTransfer")
              transfer.SetUrl("https://api.example.com/count")
              transfer.AsyncGetToString()
              return invalid ' halt reducer
            end if
            return intent
          end function
        ]
      end function
      override function reducer(state, intent)
        if intent.type = "INCREMENT"
          state.count = state.count + 1
          state.lastUpdated = createObject("roDateTime").toISOString()
        else if intent.type = "COUNT_LOADED"
          state.count = intent.payload.value
          state.lastUpdated = createObject("roDateTime").toISOString()
        end if
        return state
      end function
      override sub onSourceEvent(msg as object)
        if msg.GetResponseCode() = 200
          data = ParseJson(msg.GetString())
          m.dispatch({ type: "COUNT_LOADED", payload: { value: data.count } })
        end if
      end sub
    end class
  taskThreadSetup: |
    sub taskFunction()
      counterModel = new Models.CounterModel()
      counterReducer = new Reducers.CounterReducer()
      Rotor.createDispatcher("counter", counterModel, counterReducer)
      m.appFw.sync()
    end sub
  renderThreadUsage: |
    class CounterView extends Rotor.ViewModel
      override sub onCreateView()
        m.dispatcher = m.connectDispatcher("counter")
        m.dispatcher.getState(sub(props, state)
          props.count = state.count
        end sub)
        m.dispatcher.addListener({
          mapStateToProps: sub(props, state)
            props.count = state.count
          end sub,
          callback: m.updateCounter
        })
      end sub
      override function template() as object
        return {
          nodeType: "Label",
          id: "counterLabel",
          fields: { text: `Count: ${m.props.count}` }
        }
      end function
      sub updateCounter()
        m.render({ id: "counterLabel", fields: { text: `Count: ${m.props.count}` } })
      end sub
      sub onIncrementPress()
        m.dispatcher.dispatch({ type: "INCREMENT" })
      end sub
    end class
patterns:
  middleware:
    - "Logger middleware demonstrating pass-through. Logs intent then returns intent to continue."
    - "Async HTTP middleware using registerSourceObject('roUrlTransfer') — framework creates object, sets port, routes response to onSourceEvent()."
  reducer:
    - "Intent types INCREMENT, COUNT_LOADED mutating count and lastUpdated."
    - "Reducer returns modified state object. All mutations happen in reducer on task thread."
    - "Use m.getState() helper in reducers to access current state directly without callback."
  sourceObjects:
    - "Call m.registerSourceObject('roUrlTransfer') for identity-based objects — framework creates new instance per call, sets port, routes by GetSourceIdentity(). Returns the created object."
    - "Call m.registerSourceObject('roDeviceInfo', eventFilter) for broadcast objects — singleton per type. First call creates instance, subsequent calls return shared instance and add dispatcher as subscriber. eventFilter filters relevant events."
    - "Register broadcast objects in onCreateDispatcher() lifecycle hook; identity-based objects can be registered in middleware."
    - "Framework routes all events to reducer's onSourceEvent(msg as object)."
    - "Call m.unregisterSourceObject(sourceObject) to clean up. Broadcast: removes dispatcher subscriber, cleans up when no subscribers remain."
    - "Dispatch new intent from onSourceEvent() to update state."
  renderIntegration:
    - "ViewModel onCreateView connects to dispatcher via m.connectDispatcher(name)."
    - "getState binds initial state to props."
    - "addListener subscribes to state changes with mapStateToProps."
    - "callback updates UI via m.render on state change."
    - "Widgets can use m.dispatchTo(id, intent) to dispatch to specific dispatcher."
    - "Widgets can use m.getStateFrom(id) to access state from specific dispatcher."
  reducerMethods:
    - "m.getState() - access own dispatcher's current state"
    - "m.dispatch(intent) - dispatch intent to own dispatcher"
    - "m.dispatchTo(id, intent) - dispatch intent to another dispatcher by ID"
    - "m.getStateFrom(id) - get state from another dispatcher by ID"
    - "m.registerSourceObject(typeName, eventFilter) - create and register source object by type name; returns created (or shared) object"
    - "m.unregisterSourceObject(sourceObject) - unregister a source object"
  dispatcherAccessibility:
    taskThread: "Dispatchers created via Rotor.createDispatcher() on task thread are globally accessible from render thread and other task threads."
    renderThread: "Dispatchers created on render thread are technically accessible but rarely recommended for cross-thread use. Use for complex component internal state or local UI coordination."
resolution:
  priority: "Reducer resolves intents after middleware completes. Listeners react post-update. Middleware can halt reducer by returning invalid."
threadFlow:
  sequence:
    - "Render thread dispatches intent"
    - "Intent sent to task thread"
    - "Middleware chain executes (can halt via invalid)"
    - "Reducer updates state"
    - "State synced back to listeners"
    - "Listener callbacks fire on render thread"
    - "UI updates via render/refresh"
rules:
  - "Create dispatchers in task thread for global access; render-thread dispatchers are local-use only."
  - "All state mutations happen in reducers on task thread. Never mutate state in render thread."
  - "Use middleware for async work; return invalid to stop reducer execution."
  - "Register source objects with m.registerSourceObject(typeName). Framework creates object, sets port, handles routing (identity-based or broadcast singleton)."
  - "Filter listener updates with allowUpdate or once: true to reduce churn and improve performance."
  - "Maintain single source of truth per dispatcher/model pair. Multiple components can subscribe to same dispatcher."
  - "Use clear, descriptive intent types (e.g., 'INCREMENT', 'LOAD_DATA', 'SET_USER')."
  - "Keep models focused on specific domains (e.g., user, content, settings)."
  - "Handle all state mutations in reducer, never in middleware."
pitfalls:
  - "Avoid mutating state directly in render thread. Always dispatch intents."
  - "Render-thread dispatchers should rarely be consumed cross-thread."
  - "Don't perform state mutations in middleware; middleware is for async operations only."
  - "Forgetting to call m.registerSourceObject(typeName) before async operations prevents framework event routing."
  - "Forgetting to remove listeners can cause memory leaks. Use once: true for one-time operations."
bestPractices:
  - "Keep models focused on specific domains (e.g., user, content, settings)."
  - "Use clear, descriptive intent types."
  - "Use m.registerSourceObject(typeName) for source objects — framework creates and manages the object. Returns the created (or shared) instance."
  - "Use eventFilter with broadcast objects (roDeviceInfo, roInput) to filter relevant events in onSourceEvent(). Broadcast objects are singletons shared across dispatchers."
  - "Use m.getState() in reducers to access current state without callback."
  - "Use m.dispatchTo() and m.getStateFrom() in widgets and reducers for concise cross-dispatcher access."
  - "Filter listener updates with allowUpdate when needed for performance."
  - "Remove listeners with once: true for one-time operations."
  - "Handle all state mutations in the reducer, never in middleware."
lifecycle:
  - "createDispatcher on task thread"
  - "dispatch intent from render thread"
  - "middleware chain execution"
  - "reducer state transformation"
  - "state update committed"
  - "listener notify to render thread"
  - "UI render/refresh"
pipeline:
  - "intent emission (any thread)"
  - "middleware chain (task thread)"
  - "reducer execution (task thread)"
  - "model state commit"
  - "listener callbacks (render thread)"
  - "widget update/render"
```
