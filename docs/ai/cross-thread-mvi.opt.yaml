```yaml
ctx: Cross-Thread MVI Pattern
type: state-management / multi-thread
scope:
  threads:
    - render thread
    - task thread
  usage: Rotor Framework apps requiring synchronized state across threads
core:
  components:
    Model: "State container extending Model base class; declares initial state. Example: CounterModel with state = { count: 0, lastUpdated: invalid }"
    Reducer: "Transforms state via reducer() and optional applyMiddlewares(). Middleware runs before reducer for async operations."
    Dispatcher: "Bridge exposing createDispatcher, dispatch, getState, addListener. Connects Model and Reducer with thread-safe communication."
  flowDiagram: images/Rotor_Framework_cross-thread_MVI.jpeg
api:
  createDispatcher:
    syntax: "Rotor.createDispatcher(name, model, reducer)"
    description: "Register dispatcher with unique name, model, reducer. Task thread dispatchers are globally accessible. Render thread dispatchers are local-use only."
  dispatch:
    syntax: "dispatcher.dispatch({ type: intentType, payload: data })"
    description: "Send intents from any thread; payload optional. Triggers middleware then reducer."
  getState:
    syntax: "dispatcher.getState(sub(props, state) ... end sub)"
    description: "Callback receives current state snapshot; used for binding props. Executes callback with current state once. In reducers, use m.getState() helper to access current state directly."
  addListener:
    syntax: "dispatcher.addListener({ mapStateToProps, allowUpdate, callback, once })"
    description: "Subscribe to state changes. mapStateToProps updates props from state. allowUpdate filters when callback fires. callback or callbackWithState executes on update. once removes listener after first trigger."
  registerAsyncTransfer:
    syntax: "m.registerAsyncTransfer(transfer, context)"
    description: "Register roUrlTransfer for async HTTP tracking. Call from reducer middleware before AsyncGetToString(). Framework routes roUrlEvent to asyncReducerCallback with context data. Available in BaseReducer."
state:
  renderThread:
    - "dispatch intent to task thread"
    - "listener callbacks receive state updates"
    - "UI update via render/refresh"
  taskThread:
    - "middleware execution (async operations, logging)"
    - "reducer state update (synchronous mutations)"
    - "sync back to listeners on render thread"
examples:
  modelDefinition: |
    class CounterModel extends Model
      state = { count: 0, lastUpdated: invalid }
    end class
  reducerDefinition: |
    class CounterReducer extends Reducer
      override function applyMiddlewares()
        return [
          function(intent, state) ' Logger
            return intent ' pass-through
          end function,
          function(intent, state) ' Async HTTP
            if intent.type = "LOAD_COUNT"
              transfer = CreateObject("roUrlTransfer")
              transfer.SetUrl("https://api.example.com/count")
              transfer.SetMessagePort(m.port)
              m.registerAsyncTransfer(transfer, { requestType: "count" })
              transfer.AsyncGetToString()
              return invalid ' halt reducer
            end if
            return intent
          end function
        ]
      end function
      override function reducer(state, intent)
        if intent.type = "INCREMENT"
          state.count = state.count + 1
          state.lastUpdated = createObject("roDateTime").toISOString()
        else if intent.type = "COUNT_LOADED"
          state.count = intent.payload.value
          state.lastUpdated = createObject("roDateTime").toISOString()
        end if
        return state
      end function
      override sub asyncReducerCallback(msg as roUrlEvent, context as dynamic)
        if msg.GetResponseCode() = 200
          data = ParseJson(msg.GetString())
          m.dispatch({ type: "COUNT_LOADED", payload: { value: data.count } })
        end if
      end sub
    end class
  taskThreadSetup: |
    sub taskFunction()
      counterModel = new Models.CounterModel()
      counterReducer = new Reducers.CounterReducer()
      Rotor.createDispatcher("counter", counterModel, counterReducer)
      m.appFw.sync()
    end sub
  renderThreadUsage: |
    class CounterView extends Rotor.ViewModel
      override sub onCreateView()
        m.dispatcher = m.getDispatcher("counter")
        m.dispatcher.getState(sub(props, state)
          props.count = state.count
        end sub)
        m.dispatcher.addListener({
          mapStateToProps: sub(props, state)
            props.count = state.count
          end sub,
          callback: m.updateCounter
        })
      end sub
      override function template() as object
        return {
          nodeType: "Label",
          id: "counterLabel",
          fields: { text: `Count: ${m.props.count}` }
        }
      end function
      sub updateCounter()
        m.render({ id: "counterLabel", fields: { text: `Count: ${m.props.count}` } })
      end sub
      sub onIncrementPress()
        m.dispatcher.dispatch({ type: "INCREMENT" })
      end sub
    end class
patterns:
  middleware:
    - "Logger middleware demonstrating pass-through. Logs intent then returns intent to continue."
    - "Async HTTP middleware using registerAsyncTransfer() for roUrlTransfer tracking. Framework routes response to asyncReducerCallback()."
  reducer:
    - "Intent types INCREMENT, COUNT_LOADED mutating count and lastUpdated."
    - "Reducer returns modified state object. All mutations happen in reducer on task thread."
    - "Use m.getState() helper in reducers to access current state directly without callback."
  asyncTransfers:
    - "Call m.registerAsyncTransfer(transfer, context) in middleware before AsyncGetToString()."
    - "Framework automatically routes roUrlEvent to reducer's asyncReducerCallback(msg as roUrlEvent, context as dynamic)."
    - "Access response directly via msg (roUrlEvent) and context parameter in callback."
    - "Dispatch new intent from asyncReducerCallback() to update state."
  renderIntegration:
    - "ViewModel onCreateView obtains dispatcher via m.getDispatcher(name)."
    - "getState binds initial state to props."
    - "addListener subscribes to state changes with mapStateToProps."
    - "callback updates UI via m.render on state change."
    - "Widgets can use m.dispatchTo(id, intent) to dispatch to specific dispatcher."
    - "Widgets can use m.getStateFrom(id) to access state from specific dispatcher."
  reducerMethods:
    - "m.getState() - access own dispatcher's current state"
    - "m.dispatch(intent) - dispatch intent to own dispatcher"
    - "m.dispatchTo(id, intent) - dispatch intent to another dispatcher by ID"
    - "m.getStateFrom(id) - get state from another dispatcher by ID"
    - "m.registerAsyncTransfer(transfer, context) - register async transfer for routing"
  dispatcherAccessibility:
    taskThread: "Dispatchers created via Rotor.createDispatcher() on task thread are globally accessible from render thread and other task threads."
    renderThread: "Dispatchers created on render thread are technically accessible but rarely recommended for cross-thread use. Use for complex component internal state or local UI coordination."
resolution:
  priority: "Reducer resolves intents after middleware completes. Listeners react post-update. Middleware can halt reducer by returning invalid."
threadFlow:
  sequence:
    - "Render thread dispatches intent"
    - "Intent sent to task thread"
    - "Middleware chain executes (can halt via invalid)"
    - "Reducer updates state"
    - "State synced back to listeners"
    - "Listener callbacks fire on render thread"
    - "UI updates via render/refresh"
rules:
  - "Create dispatchers in task thread for global access; render-thread dispatchers are local-use only."
  - "All state mutations happen in reducers on task thread. Never mutate state in render thread."
  - "Use middleware for async work; return invalid to stop reducer execution."
  - "Register async transfers with m.registerAsyncTransfer() before calling AsyncGetToString(). Framework handles routing."
  - "Filter listener updates with allowUpdate or once: true to reduce churn and improve performance."
  - "Maintain single source of truth per dispatcher/model pair. Multiple components can subscribe to same dispatcher."
  - "Use clear, descriptive intent types (e.g., 'INCREMENT', 'LOAD_DATA', 'SET_USER')."
  - "Keep models focused on specific domains (e.g., user, content, settings)."
  - "Handle all state mutations in reducer, never in middleware."
pitfalls:
  - "Avoid mutating state directly in render thread. Always dispatch intents."
  - "Render-thread dispatchers should rarely be consumed cross-thread."
  - "Don't perform state mutations in middleware; middleware is for async operations only."
  - "Forgetting to call m.registerAsyncTransfer() before async operations prevents framework routing."
  - "Forgetting to remove listeners can cause memory leaks. Use once: true for one-time operations."
bestPractices:
  - "Keep models focused on specific domains (e.g., user, content, settings)."
  - "Use clear, descriptive intent types."
  - "Use m.registerAsyncTransfer() for roUrlTransfer objects to enable automatic routing."
  - "Pass context data to registerAsyncTransfer() to identify requests in asyncReducerCallback()."
  - "Use m.getState() in reducers to access current state without callback."
  - "Use m.dispatchTo() and m.getStateFrom() in widgets and reducers for concise cross-dispatcher access."
  - "Filter listener updates with allowUpdate when needed for performance."
  - "Remove listeners with once: true for one-time operations."
  - "Handle all state mutations in the reducer, never in middleware."
lifecycle:
  - "createDispatcher on task thread"
  - "dispatch intent from render thread"
  - "middleware chain execution"
  - "reducer state transformation"
  - "state update committed"
  - "listener notify to render thread"
  - "UI render/refresh"
pipeline:
  - "intent emission (any thread)"
  - "middleware chain (task thread)"
  - "reducer execution (task thread)"
  - "model state commit"
  - "listener callbacks (render thread)"
  - "widget update/render"
```
