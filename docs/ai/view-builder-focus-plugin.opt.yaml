```yaml
ctx: ViewBuilder Focus Plugin
type: navigation / focus-management
scope:
  targets:
    - FocusItem widgets (buttons, cards, menu entries, input fields)
    - FocusGroup containers (menus, carousels, grids, panels)
  state: "Focus state queryable via injected isFocused() widget method. node.isFocused field auto-managed."
  background: "Production-grade focus system developed over multiple years across POC and white-label CTV projects. Evolved into a runtime-adaptive, developer-friendly architecture that handles complex dynamic UIs with minimal configuration."
  challenge: "CTV focus is the primary input mechanism (no touch/mouse). Complex focus behavior in dynamic apps is challenging. Goal: intuitive, composable, efficient."

capabilities:
  - "Hierarchical Focus Groups with bubbling/capturing resolution (DOM-event-model inspired)"
  - "Automatic Spatial Navigation based on real-time widget geometry (supports rotated elements)"
  - "Static and Dynamic Direction Overrides (functions evaluated at nav time)"
  - "Focus Memory — auto-remembers/restores last focused item per group (configurable depth)"
  - "Long-Press Detection with duration timer and handler callbacks"
  - "Focus State Query via injected isFocused() widget method"
  - "Programmatic Focus Control (setFocus, triggerKeyPress, enableFocusNavigation)"
  - "Deep Search Resolution — finds targets at any depth in widget hierarchy"
  - "Spatial Enter — geometry-aware group entry from specific directions"
  - "Per-Direction Configuration for spatial enter (AA: { right: true, down: true })"
  - "Native Focus Bridge for SceneGraph integration (keyboard, video)"
  - "Disabled Item Handling — skips inactive elements during navigation"

templateKeys:
  focus: "FocusItem — individual focusable widget. Template key: focus: { ... }"
  focusGroup: "FocusGroup — container managing child navigation. Template key: focusGroup: { ... }"
  constraint: "A widget CANNOT have both focus and focusGroup. Plugin validates at mount, logs error if both present."

core:
  strategies:
    bubbling: "Upward search (child → parent → grandparent) when local nav fails. 'I can't go further, ask parents.'"
    capturing: "Downward resolution (group → nested group → focus item) via defaultFocusId. Converts group/ID → concrete FocusItem."
    spatial: "Automatic in-group navigation based on widget geometry. ONLY within single group, cannot cross groups."
    deepSearch: "If defaultFocusId not in immediate children, searches ALL descendants (any depth) for FocusItems and nested Groups."
  workflow: "User Action → Static Direction → Spatial Nav → Bubbling(↑) → Capturing(↓ resolve target)"

props:
  focusItem:
    isEnabled: "boolean (default: true) — enable/disable focus capability. Disabled items skipped by spatial nav."
    enableNativeFocus: "boolean (default: false) — sets native SceneGraph focus on node (for keyboard, video)"
    enableSpatialNavigation: "boolean (default: FALSE) — opt-in to geometry-based nav within parent group"
    up/down/left/right/back: "string (nodeId) | function() as string | false | true — direction overrides"
    onFocusChanged: "sub(isFocused as boolean) — called when focus state changes"
    onFocus: "sub() — called when widget gains focus"
    onBlur: "sub() — called when widget loses focus"
    onSelect: "sub() — called when OK button pressed while focused"
    longPressHandler: "function(isLongPress as boolean, key as string) as boolean — return true if handled (stops bubbling)"
    keyPressHandler: "function(key as string) as boolean — handle non-navigation keys (play, pause, rewind, etc.). Return true if handled (stops bubbling to ancestor groups)"
  focusGroup:
    defaultFocusId: "string | function() as string — default focus target when group receives focus"
    lastFocusedHID: "string (auto-managed) — remembers last focused item HID"
    enableLastFocusId: "boolean (default: true) — when true, stores lastFocusedHID and uses it on re-entry (bypassing defaultFocusId). When false, defaultFocusId is ALWAYS evaluated on every focus entry — if it's a function, it's called every time."
    enableDeepLastFocusId: "boolean (default: false) — ancestor groups also store lastFocusedHID from ANY depth"
    enableSpatialEnter: "boolean | AA (default: false) — spatial nav when entering from direction. AA: { right: true, down: true }"
    up/down/left/right/back: "string | function() as string | boolean — group-level navigation (activated via bubbling)"
    onFocusChanged: "sub(isFocused as boolean) — group focus-chain callback (true = descendant has focus)"
    onFocus: "sub() — called when group enters focus chain"
    onBlur: "sub() — called when group leaves focus chain"
    longPressHandler: "function(isLongPress as boolean, key as string) as boolean — group-level long press handler"
    keyPressHandler: "function(key as string) as boolean — group-level handler for non-navigation keys. Receives keys not handled by focused item's keyPressHandler. Return true to stop bubbling"

directionValues:
  onFocusItem:
    string: "Static navigation to that node ID — EXITS group immediately"
    function: "Dynamic, evaluated at runtime — return node ID or boolean"
    false: "BLOCKS direction (nothing happens, key consumed)"
    true/empty/undefined: "Falls through to spatial navigation"
  onFocusGroup:
    string: "Navigate to that group/item — may EXIT group"
    function: "Dynamic, evaluated at runtime"
    true: "BLOCKS exit (stays on current, key consumed)"
    false/undefined: "Continue bubbling to next ancestor"

resolution:
  priority:
    1: "Static direction (FocusItem.direction) — EXITS immediately if defined"
    2: "Spatial navigation inside current group — STAYS in group"
    3: "BubblingFocus to parent groups — may EXIT via group.direction"

rules:
  RULE_1: "Widget types: focus:{} → FocusItem | focusGroup:{} → FocusGroup | none → not in system"
  RULE_2: "FocusItem direction: string=static, function=dynamic, false=block, true/empty=spatial fallthrough"
  RULE_3: "Nav priority: 1)Static direction 2)Spatial nav (within group) 3)BubblingFocus"
  RULE_4: "Spatial nav ONLY within single group. Cannot cross groups. Candidates: FocusItems + child Groups with enableSpatialNavigation:true"
  RULE_5: "Group direction triggers ONLY when: FocusItem NO static dir AND spatial found NOTHING AND bubbling reaches group"
  RULE_6: "Group direction: string=navigate(may EXIT), true=BLOCKS(stays), false/undefined=continue bubbling"
  RULE_7: "group.right=true does NOT block internal spatial nav. Only blocks EXITING when spatial finds nothing."
  RULE_8_exitMethods:
    method1: "FocusItem explicit direction → EXITS immediately (bypasses group config)"
    method2: "Group direction via BubblingFocus → EXITS when spatial fails"
    method3: "Ancestor group direction → EXITS when child groups pass"
  RULE_9: "group.left=true blocks exit. EXCEPTION: FocusItem explicit directions still work!"
  RULE_10_flow: "FocusItem(no dir) → Spatial(nothing) → Group.dir? → 'nodeId'=EXIT | true=STOP | false=continue | no ancestor=stay"
  RULE_11_capturingPriority:
    1: "group.lastFocusedHID (if exists and still valid) [AUTO-SAVED]"
    2: "group.defaultFocusId [CONFIGURED]"
    3: "Deep search (if defaultFocusId not found immediately)"
    4: "Child member fallback — if no defaultFocusId, picks an available group member. Order is non-deterministic (AA iteration). defaultFocusId always recommended."
  RULE_11b_focusMemory:
    enableLastFocusId: "boolean (default: true) — when true, stores lastFocusedHID; on re-entry lastFocusedHID takes priority over defaultFocusId. When false, defaultFocusId is ALWAYS used on every focus entry (function is called every time), making focus resolution fully dynamic."
    enableDeepLastFocusId: "boolean (default: false) — ancestors also store lastFocusedHID from any depth"
    useCase_enableLastFocusId_false: "Spotlight rail always starting from first item, or group where entry point depends on runtime state. Note: if combined with no defaultFocusId, always falls back to non-deterministic child member on every entry. Always pair with a defaultFocusId (preferably a function)."
    useCase_enableDeepLastFocusId: "Nested groups (mainMenu > subMenu > item): set enableDeepLastFocusId:true on mainMenu to remember deeply nested item."
  RULE_12: "defaultFocusId targets: FocusItem ID → direct focus | Group ID → recursive capturing | nonExistent → deep search"
  RULE_13: "Deep search: triggers when defaultFocusId not found in immediate children. Searches all descendant FocusItems and Groups."
  RULE_14: "enableSpatialEnter: entering group uses spatial nav from direction. Finds closest item, falls back to defaultFocusId. Ignores lastFocusedHID."
  RULE_15_decisionTree: |
    User presses direction key:
      1. FocusItem.direction exists? → Use it (may EXIT group)
      2. Spatial nav finds item? → Navigate (STAYS in group)
      3. BubblingFocus: Group.direction?
         → "nodeId" → EXIT to that target
         → true → BLOCK (stay)
         → undefined → Continue to ancestor
      4. No more ancestors? → STAY on current item

api:
  injectedMethods: "Methods injected DIRECTLY onto widget (not under widget.plugins.focus)"
  methods:
    isFocused: "widget.isFocused() — returns true if focused (FocusItem) or in focus chain (Group). Returns false for widgets without focus config."
    setFocus: "widget.setFocus(command, enableNativeFocus?) — focus self (true), blur (false), or focus by ID (string). Returns boolean."
    getFocusedWidget: "widget.getFocusedWidget() — returns currently focused widget across entire system"
    enableFocusNavigation: "widget.enableFocusNavigation(enabled) — globally enable/disable all navigation"
    isFocusNavigationEnabled: "widget.isFocusNavigationEnabled() — check global navigation state"
    proceedLongPress: "widget.proceedLongPress() — manually trigger long press navigation action"
    isLongPressActive: "widget.isLongPressActive() — check if long press active"
    triggerKeyPress: "widget.triggerKeyPress(key) — simulate key press for testing/programmatic nav"
    setGroupLastFocusedId: "widget.setGroupLastFocusedId(id) — update lastFocusedHID. On FocusItem: updates parent group. On FocusGroup: updates own."

patterns:
  basicButton: |
    focus: {
      onFocusChanged: sub(isFocused)
        m.node.blendColor = isFocused ? "0x3399FFFF" : "0xFFFFFFFF"
      end sub,
      onSelect: sub() -> m.getViewModel().handleAction()
    }
  formSpatialNav: |
    focusGroup: { defaultFocusId: "emailInput" }
    children: emailInput, passwordInput, loginButton
      each: focus: { enableSpatialNavigation: true, onSelect: sub() }
    After keyboard: m.setFocus("passwordInput") / m.setFocus("loginButton")
  sidebarContent: |
    appLayout: focusGroup: {
      defaultFocusId: function() -> wasContentFocused ? "content" : "menu",
      onBlur: sub() -> cache which child was focused
    }
    menu: focusGroup: { right: "content", back: "content" }
      menuItems: focus: { onFocus: sub() -> activateSection() }  (passive navigation)
    content: focusGroup: { left: "menu", defaultFocusId: function() -> activePageId }
  horizontalCarousel: |
    focusGroup: {
      defaultFocusId: function() -> getCurrentCardId(),
      left: function() -> scrollToPrev() (returns ID or false),
      right: function() -> scrollToNext(),
      longPressHandler: function(isLongPress, key) -> handleContinuousScroll(),
      onBlur: sub() -> pausePreview()
    }
  verticalRailCarousel: |
    focusGroup: {
      defaultFocusId: function() -> getActiveRailId(),
      up/down: function() -> navigateToRail(direction),
      onFocus: sub() -> expandActiveRail(),
      onBlur: sub() -> collapseAllRails()
    }
  cardWithDispatch: |
    focus: {
      enableNativeFocus: false,
      onFocus: sub() -> dispatchCardMetadata(),
      onSelect: sub() -> openDetailPage()
    }
  modalLocked: |
    focusGroup: { defaultFocusId: "confirm", left:true, right:true, up:true, down:true, back:true }
    Captures all focus — no exit possible
  nestedBubbling: |
    outer: focusGroup: { down: "footer" } (catches bubbling)
    inner: focusGroup: { defaultFocusId: "item1" } (no down → bubbles up)
  settingsWithSync: |
    menu + panel bidirectional nav
    On panel change: m.children.menu.setGroupLastFocusedId("menuItem_" + id)
    Ensures LEFT from panel focuses correct menu item
  conditionalFocus: |
    if entry.isAction -> focus: { onSelect: sub() } (requires OK press)
    else -> focus: { onFocus: sub() } (activates on navigation)
  dynamicDirections: |
    focus: { up: function() -> isExpanded ? "expandedHeader" : "collapsedHeader" }
    right: function() -> hasDetail ? "detailPanel" : "" (fall through to spatial)
  spatialEnter: |
    focusGroup: { enableSpatialEnter: true } — closest item when entering
    Per-direction: enableSpatialEnter: { right: true, down: true }
  deepFocusMemory: |
    focusGroup: { enableDeepLastFocusId: true } — remembers ANY depth
    User focuses nested item3 → nav away → return → goes back to item3
  disableFocusMemory: |
    focusGroup: { enableLastFocusId: false } — defaultFocusId is ALWAYS evaluated on every entry (never bypassed by lastFocusedHID). If defaultFocusId is a function, it runs every time.
  animatedIndicator: |
    focusGroup: { onFocusChanged: sub(isFocused) -> animate focusBar opacity }
  transitionControl: |
    m.enableFocusNavigation(false) — during animation
    m.enableFocusNavigation(true) — re-enable after
    m.setFocus("firstItemInNewView")
  disabledWidget: |
    focus: { isEnabled: false } — plugin skips during navigation

bestPractices:
  visualFeedback: "Always handle focus state visually via onFocusChanged or m.isFocused() in field expressions."
  defaultFocusId: "Always specify group.defaultFocusId. Without it, child-member fallback picks a non-deterministic member (no focus loss, but unpredictable order)."
  organizeGroups: "Structure groups based on UI layout and navigation flow. Flat is insufficient for complex UIs."
  explicitDirections: "Use explicit directions for critical cross-section nav. Spatial alone may be unpredictable."
  onFocusVsOnSelect: "onFocus for passive selection (preview). onSelect for active confirmation (submit, open, play)."
  transitionGuard: "Disable focus navigation during animations/transitions to prevent race conditions."
  dynamicFunctions: "Use functions for defaultFocusId and directions when targets depend on runtime state."

pitfalls:
  focusLoops: "Circular navigation. Solution: Use false to block or plan paths."
  missingDefaultFocus: "Group without defaultFocusId → non-deterministic child member fallback (not focus loss, but unpredictable order). Solution: Always specify defaultFocusId."
  disabledItems: "Focusing isEnabled=false items. Solution: Check before programmatic focus."
  nativeFocusConflicts: "Mixing native/plugin focus. Solution: Use enableNativeFocus consistently."
  groupHierarchy: "Wrong parent-child relationships. Solution: Ensure groups contain items in tree."
  spatialScope: "Expecting cross-group spatial nav. Solution: Only within one group (RULE #4)."
  blockingMisunderstanding: "group.right=true blocking internal spatial. Solution: Only blocks EXIT (RULE #7)."
  bothFocusAndFocusGroup: "Widget with both keys → silently skipped. Solution: Use one or the other."
  spatialNavDefault: "Assuming enableSpatialNavigation is true. Solution: Default is FALSE, opt-in explicitly."

troubleshooting:
  notResponding:
    - "widget.isFocusNavigationEnabled() === false? → enableFocusNavigation(true)"
    - "widget.getFocusedWidget() === invalid? → no initial focus set, call setFocus()"
    - "widget.focus.isEnabled === false? → item disabled"
  groupNavNotWorking:
    - "Check defaultFocusId matches existing ID within group (RULE #12)"
    - "Verify items are actual descendants in widget tree"
    - "Test direction values: true=blocks, string=navigates, false=bubbles (RULE #6)"
    - "Check bubbling flow through parents (RULE #10)"
  stateNotUpdating:
    - "Verify onFocusChanged properly defined"
    - "Use m.isFocused() to query focus state"
    - "Inspect m.node.isFocused field directly"
  unexpectedExit:
    - "Review 3 exit methods (RULE #8)"
    - "FocusItem explicit directions override group blocking (RULE #9)"
    - "Check priority: static → spatial → bubbling (RULE #3)"

lifecycle:
  beforeMount: "Register focus item or group when widget mounts. Validates not both focus+focusGroup."
  beforeUpdate: "Remove old config, merge new config (deepExtendAA), re-register."
  beforeDestroy: "Unregister item/group, clear global focus if this widget held it."

pipeline:
  1: "Configuration Parse — determines FocusItem (focus:) vs FocusGroup (focusGroup:)"
  2: "Instance Creation — creates FocusItemClass or GroupClass"
  3: "Registration — stores in FocusItemStack or GroupStack"
  4: "Hierarchy Tracking — ancestor groups computed dynamically via HID matching"
  5: "State Initialization — adds node.isFocused field. For ViewModel widgets only (isViewModel=true), also initializes viewModelState.isFocused to false. Simple child widgets are excluded because they share the parent's viewModelState by reference."
  6: "Focus Application — calls onFocusChanged, onFocus/onBlur callbacks"
  7: "State Update — updates node.isFocused on all focus-configured widgets. Updates viewModelState.isFocused only on ViewModel widgets. Use m.isFocused() for reliable per-widget focus queries."
  8: "Navigation Handling — static → spatial → bubbling priority chain"
  9: "Group Notification — notifies all affected ancestor groups of focus chain changes"
  10: "Cleanup — removes config and destroys instances on widget destroy"

stateManagement:
  autoInjected:
    - "node.isFocused field — on all widgets with focus config"
    - "viewModelState.isFocused — ONLY on ViewModel widgets (isViewModel=true). Not set on simple child widgets because they share the parent's viewModelState by reference, which would cause conflicts."
  widgetMethod: "m.isFocused() — returns true if focused (FocusItem) or in focus chain (Group). Recommended for all widgets. Works reliably on both ViewModels and simple widgets."
  accessPattern: "Use m.isFocused() in field expressions and callbacks for reactive UI updates"
```
